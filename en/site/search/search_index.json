{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Page","title":"Home"},{"location":"#home-page","text":"","title":"Home Page"},{"location":"page-not-found/","text":"Page not found.","title":""},{"location":"page-not-found/#page-not-found","text":"","title":"Page not found."},{"location":"key-concepts/access-control-and-entitlement-management/","text":"Access Control and Entitlement Management Today, enterprise applications seek ways of enforcing security that allows the right people to access the right resources with restrictions enforced by enterprise policies. Identity and entitlement management systems, as a whole, attempt to address these security considerations. These systems help enterprise architects and developers in their application requirement implementations and try to significantly ease the burden of security-related implementations. These identity and entitlement management systems are governed by industry standard specifications, hence supporting security requirements for heterogeneous applications becomes easy. Click here for more information on Access control. Types of access control The following table describes the various types of access control. Access Control Type Description Access Control Lists Access control lists are the oldest and most basic form of access control. This type was primarily adopted for use in operating systems. This maintains a set of users and operations that can be performed on a resource as a mapping. This is easy to implement due to the use of maps. However, this is not scalable for larger user bases and can become difficult to manage. Role-based Access Control Role-based Access Control (RBAC) is an approach used to restrict access to authorized users based on their role. This is a static permission model which provides access control. It is used by the majority of enterprises with more than 500 users. This access control type is used when all users are categorized into different roles. The roles define the resources that can be accessed by users assigned to that role. This type of access control reduces management overhead. These users and roles can also be externalized using user stores. These roles need to be managed carefully. There can be instances where a user is assigned to multiple roles. This is a subset of ABAC. Static permissions for roles can be given by updating permission tree in WSO2 Identity Server. Click here for information on Configuring roles and permissions. Attribute-based Access Control Attribute-based access control (ABAC) defines a new access control paradigm whereby access rights are granted to users through the use of policies that combine attributes together. Here, authorization happens based on attributes. This access control type addresses the limitations of role-based access control to provide a more fine-grained approach. This can be based on the attributes of the user, the environment, or even the resource itself. This is more flexible when compared with the role-based approach. There is no need to know the user prior to granting access. Policy-based Access Control This type of access control addresses the requirement to have a more uniform access control mechanism. This helps larger enterprises to have uniform access control for the large amount of organizational units. This is helpful when carrying out security audits. This is the most complex form of access control. This involves specifying policies unambiguously using XACML and using authorized attribute sources in the enterprise. Here Policy Based Access Control(PBAC) (also called Rule-based access control) is an extension of ABAC where attributes are used in writing policies. Introducing XACML XACML (eXtensible Access Control Markup Language) is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that surpasses other policy standards by being a fine-grained authorization mechanism. Although XACML was introduced as a standard by OASIS in 2003, not many organizations that have adopted it yet. This is because most organization's lack of interest in moving towards a XACML based solution for authorization. The following can be some of the reasons for this: Many software designer and developers lack a clear understanding of features, importance, and advantages of XACML. It is comparatively difficult to implement a XACML solution when compared with a typical JDBC or hard-coded authorization system. Performance of XACML-based authorization system may be less than adequate. The complexity of defining and managing XACML policies. However, current market trends indicate that there is some motivation for XACML-based authorization systems. This section includes some architectural and implementation details on XACML with an existing XACML engine. To summarize, XACML describes both an access control policy language, request/response language, and reference architecture. The policy language is used to express access control policies (who can do what, when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). The reference architecture proposes a standard for deployment of necessary software modules within an infrastructure to allow efficient enforcement of policies. WSO2 Identity Server uses XACML as a tool for controlling access to applications. Recommended reading For more information on XACML specifications and other related information, see the OASIS website . Why XACML Most of the organizations still use legacy systems with inbuilt authorization logic. Sometimes, one organization contains a large number of information systems and applications that each system or application uses for their own process for authorization. Today, authorization has become more complex because users within organizations and outside need access to shared data and have the need to collaborate efficiently. Therefore, this has been challenging task to manage these legacy systems, custom authorization systems. However, XACML offers a solution to this problem. Most traditional authorization systems mostly have the following features: Authorization logic is hard-coded into the source code. Authorization logic is stored in databases that could only be readable and understandable by the underlying application The following are the some goals that current organizations are looking at from an authorization system. Can business managers (who should determine how access controls would be implemented) define and modify different authorization logic? Can we find new IT technicians to manage these legacy systems? Especially when those who developed the system have left the organization? Can different authorization logic be modified without any source code changes in a dynamic way? Is authorization system capable of evaluating following rule? \u201cX resource can be accessed by the Users who are from example.com domain and whose age is greater than 21 years old\u201d If we are going to implement a new information system with the organization, can we re-use the authorization logic of a legacy system? Can we achieve a fine-grained authorization level without defining a large number of static combinations? Are the authorization systems capable of answering the questions such as: \u201cCan a user, Bob, transfer X amount from Y current account at 1.00pm?\u201c Clearly, the above goals cannot be achieved from a traditional authorization system. However, a XACML-based authorization solution can help to achieve all of these goals, because XACML: is a standard which is ratified by OASIS standards organization. is a policy language implemented using XML which is an industry standard. supports Attribute-based Access Control (ABAC) and evaluation can be done with the additional data retrieved from Policy Information Point (PIP) which is defined by the XACML reference architecture. Note Attribute-based Access Control(ABAC) ABAC is an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes etc.). This model supports boolean logic , in which rules contain \"IF, THEN\" statements about who is making the request, the resource, and the action. For example: IF the requestor is a manager, THEN allow read/write access to sensitive data. contains reference architecture which is provided to externalize the authorization system. The Policy Decision Point (PDP) offers authorization as a service in your infrastructure. Authorization algorithms can be removed from the application logic and applications can query the PDP via their own Policy Enforcement Points (PEP). provides fine-grained authorization with higher level of abstraction by means of policies and rules. supports dynamic evaluation of policies by using the Policy Information Point (PIP). can publish multiple policies into external PDPs. XACML system architecture Policy Decision Point (PDP) evaluates policies against access requests provided by Policy Enforcement Points (PEP). To provide the decisions, PDP may also need to query a Policy Information Point (PIP) to gather descriptive attributes about the user or any other missing attribute in the request. Policy Administration Point (PAP) is used to manage the PDP and PIP functionality. XACML terminology The XACML reference architecture illustrated above is comprised of the following four 'building blocks'. Policy Enforcement Point (PEP) : The system entity that performs access control by making decision requests and enforcing authorization decisions. This is the entity that sends the XACML request to the Policy Decision Point (PDP) and receives an authorization decision. Policy Decision Point (PDP) : The system entity that evaluates an applicable policy and returns an authorization decision. Policy Information Point (PIP) : The system entity that acts as a source of attribute values. If there are missing attributes in the XACML request that is sent by PEP, PIP would find them for the PDP to evaluate the policy. Policy Administration Point (PAP) : The system entity that creates a policy or policy set and manages them. XACML engine architecture The WSO2 Identity Server is a major player in the XACML and open source world. The Identity Server supports XACML 3.0, which is based on Balana XACML implementation . As the source code, distribution and documentation are available for free, it is possible to analyze and understand the architecture behind it. You can find source code from here . This section provides some information regarding the architecture of the XACML engine (or the entitlement engine) of the WSO2 Identity Server. The XACML engine of the WSO2 Identity Server has two major components, i.e., PAP and PDP. The section below focuses on Policy Decision Point (PDP). The following diagram represents the component architecture of the PDP. The following provides a more detailed information on the various components available in the PDP architecture. Entitlement Admin Service All PDP configurations are exposed via this API as a Web service which you need to have certain privileges to access. The following functions can be done by calling this API. Invalidating caches Refreshing policy, attribute, resource finder modules Retrieving PDP configurations Includes the function for testing the Test PDP with a given sample request or a sample request with given policies Entitlement Service Actual XACML authorization API is exposed via this API as a Web service. This service supports the following three communication methods with PEP. SOAP-based Web service Thrift binary protocol (this is much faster than SOAP) WS-XACML (This is the standard way but not popular) Balana PDP This is the core of the engine. Balana PDP has been initialized with all the attribute finders, resource finders and policy finder modules that are plugged with WSO2 Identity Server. Balana Test PDP This is same as Balana PDP. However, this instance has been initialized with the PAP policy store. It means, policies that are defined by PAP can be evaluated by using this PDP instance. There is no policy caching or decision caching with this. Therefore, this can only be used for testing your policies in the PAP store. Web service API for Balana Test PDP is exposed via the Entitlement Admin Service with method name \u201cdoTestRequest()\u201d. Carbon Policy Finder This module finds policies from different policy stores to evaluate a XACML request. The following is a high-level diagram of how this works. Any number of policy finder modules can be plugged with the Carbon policy finder. You need to implement the CarbonPolicyFinderModule interface to write a new module and register it using the configuration file called entitlement.properties.xml in IS_HOME /repository/components/features/org.wso2.carbon.identity.xacml.server_5.8.145 directory . By default, WSO2 Identity Server is shipped with a Carbon registry-based policy finder module that can retrieve policies from a registry collection, where the collection path is configurable using a property value in the entitlement.properties.xml file. All modules are initialized and policies are loaded into memory when the Carbon policy finder is used. Loaded policies are kept as a policy collection where you can use your own implementation to access them. A written policy collection implementation can be registered using the entitlement.properties.xml file. The default implementation uses an in-memory cache and creates an effective policy for a given XACML request. Therefore, the Carbon policy finder always finds effective policies from the policy collection where it is recommended to be kept in-memory. However, if any update in the policy store happens, the Carbon policy finder can be re-initialized automatically by the module that you have written, or you can re-initialize it by using the Web service API (Entitlement Admin Service). Alternatively, you can do it manually using the Identity Server Management Console. When you are writing a new module, you need to consider the following in addition to policy retrieving and re-initializing. Policy ordering - The order which policies are evaluated. Policy combining algorithm Note There are Policy Combining Algorithms which are used by Policy Sets and Rule Combining Algorithms which are used by Policies . Each of the algorithms mentioned below has its Policy Combining algorithm and its Rule Combining algorithms as follows: Standard combining algorithms defined in XACML 3.0: urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-overrides urn:oasis:names xacml:1.0:rule-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:only-one-applicable urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-unless-deny These algorithms are explained in detail as follows, Deny Overrides: This combining algorithm combines decisions in such a way that if any decision is a Deny, then that decision wins. Deny overrides is one of the safest combining algorithms since it favors a Deny decision. However, if none of the children return a Deny decision, then the combining algorithm will never produce a Deny. Permit Overrides: This combining algorithm combines decisions in such a way that if any decision is a Permit, then that decision wins. The permit overrides combining algorithm can be interesting when: At least one child must return a Permit for access to be granted overall regardless of restrictions. One wants to return all the reasons why access is being denied. This is what one could call a \u201cgreedy deny overrides\u201d.Forinstanceifthe reason for not being able to view a resource is that(a) you are not the owner and (b) you are in the wrong department, then we could rework the previous example as follows. When any of the deny reason triggers, the response would be denied with all the applicable reasons for access being denied: Policy Set (deny overrides): role==manager AND action==view AND resourceType==resource - Policy 1 (permit overrides) - Rule 1: deny if resourceOwner != userId + Advice(\u201cyou are not the owner of the resource\u201d) - Rule 2: deny if rsourceDepartment != userDepartment+ Advice(\u201cyou are not in the same department as the resource) - Policy 2 - Rule 1: permit First Applicable: This combining algorithm combines decisions in such a way that the final decision returned is the first one produced either of Permit or Deny. ** ** First applicable is useful to shortcut policy evaluation. For instance, if a policy set contains a long series of not applicable policies and one applicable policy which returns either of Permit or Deny, then if that policy comes first and does produce Permit or Deny, the PDP will stop there and not process the other siblings. Deny Unless Permit | Permit Unless Deny: In XACML there are 4 possible decisions: Permit, Deny, NotApplicable, and Indeterminate. Sometimes, it is desirable to hide the NotApplicable and Indeterminate decisions to only allow for Permit or Deny. It makes the PEP logic potentially simpler. Only One Applicable: This combining algorithm exists only for policy sets to combine policy sets and policies. It cannot be used to combine rules. With this combining algorithm, in order for either of a Permit or Deny to be returned, then only one of the children must produce a valid decision \u2013 whether Deny or Permit. Ordered Deny Overrides | Ordered Permit Overrides: The ordered combining algorithms combine decisions in the same way as their (unordered) cousins. In, addition they bring the guarantee that policies, policy sets, and rules are considered in the order in which they are defined. The need to define an ordered combining algorithm stems from the fact the XACML specification does not specify whether order matters in the deny-overrides and permit-overrides combining algorithms. How to retrieve referenced policies Carbon Attribute Finder This module helps to find the missing attribute for a given XACML request. The following is the high-level diagram for both the Carbon attribute and resource finders. Any number of PIP attribute finder modules can be plugged with the Carbon attribute finder. You need to implement the PIPAttributeFinder interface to write a new module and register it using the entitlement.properties configuration file. By default, WSO2 Identity Server is shipped with a DefaultAttributeFinder that communicates with the underlying user store of the Identity Server. The default user store of the Identity Server is ApacheDS where it can be changed using user-mgt.xml file. See Configuring the Realm for more information. All modules would be initialized and supported attribute Ids are retrieved for each module. During runtime, the Carbon attribute finder checks for the support attribute Id and hands it over to the proper module to handle. A caching machine is used by the Carbon attribute finder for caching the findings or the attribute finder module itself can handle it. Carbon Resource Finder This is used to retrieve children or descendant resources of a given root level resource value. Basically, it is used to fulfill the requirement of a multiple decision profile. The implementation is same as the PIP attribute finder module. By default, WSO2 Identity Server is shipped with DefaultResourceFinder (which is the implementation of PIPResourceFinder) that communicates with Carbon registry resources. XACML policy language structure and syntax In order to render an authorization decision , it is possible to combine the two separate policies to form the single policy applicable to the request. XACML defines three top-level policy elements: Element that contains a boolean expression that can be evaluated in isolation, but that is not intended to be accessed in isolation by a PDP . So, it is not intended to form the basis of an authorization decision by itself. It is intended to exist in isolation only within an XACML PAP , where it may form the basic unit of management. Element that contains a set of elements and a specified procedure for combining the results of their evaluation. It is the basic unit of policy used by the PDP , and so it is intended to form the basis of an authorization decision. Element that contains a set of or other elements and a specified procedure for combining the results of their evaluation. It is the standard means for combining separate policies into a single combined policy . As XACML is used in Attribute-based Access Controlling, in XACML all the attributes are categorized into the following four main categories: But from XACML 3.0, custom categories are also supported. Subject Resource Action Environment A Rule is the most elementary unit of policy . It may exist in isolation only within one of the major actors of the XACML domain. The main components of a Rule are as follows: This defines the set of requests to which the rule is intended to apply in the form of a logical expression on attributes in the request. The effect of the rule indicates the rule -writer's intended consequence of a \"True\" evaluation of the rule . Two values are allowed: \"Permit\" and \"Deny\". A Boolean expression that refines the applicability of the rule beyond the predicates implied by its target . Therefore, it may be absent. Obligation expressions may be added by the writer of the policy. When a PDP evaluates a policy containing obligation expressions, it evaluates the obligation expressions into obligations and returns certain of those obligations to the PEP in the response context. AttributeSelector - This allows the policy to specify an attribute with given identifier, category and data type. The AttributeSelector on the other hand, provides a mean to lookup the value of attributes using a XPath query by specifying the data type and XPath expression. Attribute selectors are then executed against the XML content that may have been sent along in the initial XACML request. A sample XACML 3.0 policy is as follows: Policy xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 PolicyId= samplePolicy RuleCombiningAlgId= urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-overrides Version= 1.0 Target AnyOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue AttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action DataType= http://www.w3.org/2001/XMLSchema#string MustBePresent= true / /Match /AllOf /AnyOf /Target Rule Effect= Permit RuleId= permit / /Policy Improvements in XACML 3.0 The XACML 3.0 core specification highlights the following main changes in comparison with XACML 2.0. Custom attribute categories Custom attribute categories can be defined with XACML 3.0. However, in XACML 2.0, attributes have been organized into subject, resource, environment or action. For instance, lets's say that you want to create an attribute category called \u201cfoo\u201d in your policy and request. You can do it with XACML 3.0 easily. According to the XACML 3.0 policy schema, the category of XACML element is identified by a XML attribute called \u201c Category \u201d. In XACML 2.0 Policy, you can define the attribute designator element as follows, However, it must be a pre-defined category such as subject, resource, environment or action. ResourceAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / In a XACML 3.0 Policy, you can define it as follows. Category can be anything as it is defined as an attribute of the AttributeDesignator element. AttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id Category= resource DataType= http://www.w3.org/2001/XMLSchema#string / Improvements in Obligation In general, obligations can have the following: An Obligation has an identifier, which is used to distinguish different types of obligations An Obligation can have arguments Obligations apply to Permit (or Deny) decisions only A PDP will return, as part of a Permit or Deny response, a (possibly empty) subset of the obligations that appear in the policy. There are several improvements with Obligations in XACML 3.0 when compared to 2.0. One of the main improvements is the introduction of Obligation Expressions . This adds dynamic expressions into the obligation statements. For a more in-depth understanding, see the following example: Let's assume that you want to do following with the Obligation: \u201cOn deny, inform the PEP to send an email to the user\u201d. In XACML 2.0, you need to define the obligation element with the user email statically. Obligation ObligationId= send-email FulfillOn= Deny AttributeAssignment AttributeId= email DataType= http://www.w3.org/2001/XMLSchema#string user@foo.com /AttributeAssignment /Obligation However, the user may not be same for each XACML request that is evaluated. Therefore it is not possible to configure the email statically in the Obligation element. Obligation can only inform PEP to send an email to user (it lets the PEP figure out the value of user\u2019s email). Obligation ObligationId= send-email FulfillOn= Deny AttributeAssignment AttributeId= text DataType= http://www.w3.org/2001/XMLSchema#string please send email to user /AttributeAssignment /Obligation However, in XACML 3.0, the email of each user can be retrieved using PIP in dynamically as we can define an expression element inside the ObligationExpression . Therefore, obligation can inform PEP to send an email to address. ObligationExpression ObligationId= send-email FulfillOn= Deny AttributeAssignmentExpression AttributeId= email DataType= http://www.w3.org/2001/XMLSchema#string AttributeDesignator AttributeId= email Category= urn:oasis:names:tc:xacml:1.0:subject-category:access-subject DataType= http://www.w3.org/2001/XMLSchema#string MustBePresent= false / /AttributeAssignmentExpression /ObligationExpression In XACML 2.0, obligations can only be added to policies and policy sets. However, with XACML 3.0, rules can also contain obligations. At the root of all XACML policies, is a policy or a policy set . A policy represents a single access control policy, expressed through a set of rules. A policy set is a container that can hold other policies or policy sets, as well as references to policies found in remote locations. Introducing Advice Advice is a newly introduced feature with XACML 3.0. Advice is similar to obligations and it shares much of its syntax. The difference is contractual: the PEP can disregard any advice it receives. PEPs do not have to comply with advice statements; PEPs can consider or discard the statement. A common scenario is to explain why something was denied: \u201cUser bob is denied because he does not have a valid email\u201d. The XACML specification says that any advice returned with a decision can be safely ignored by compliant PEPs. This means that PEPs should work as described in the previous section, regardless of what the PEP does with the advice it may receive. For example, a PEP must allow access if it receives a Permit decision with no obligations, regardless of any advice in the decision. Improvements in Target Since it is possible to define custom attribute categories, there are improvements in some related elements in the XACML 3.0 policy, when compared to 2.0. With XACML 3.0, the Target element can be used to define more complex authorization logic within itself when compared with 2.0. In XACML 2.0, the Target element contains the OR and AND relationship between the same category. However, in XACML 3.0, AllOf and AnyOf elements have been introduced to Target element. That clearly helps to define the OR and AND relationship between different categories. As an example, let's look at a Target element. In XACML 2.0, we have an AND relationship between foo1 and foo2 resources and an OR relationship between bar1 and bar2 actions. However, we cannot create an OR relationship between a foo1 resource and bar1 action. so we cannot define something such as \u201cTarget would be matched when Bob can access the foo resource or do a bar action\u201d by using the Target element. Target Resources Resource ResourceMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string foo1 /AttributeValue ResourceAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / /ResourceMatch ResourceMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string foo2 /AttributeValue ResourceAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / /ResourceMatch /Resource /Resources Actions Action ActionMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar1 /AttributeValue ActionAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /ActionMatch /Action Action ActionMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar2 /AttributeValue ActionAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /ActionMatch /Action /Actions /Target XACML 3.0 has an AND relationship between \u201c foo \u201d resource and \u201c bar1 \u2033 role and an OR relationship between \u201c bar2 \u2033 action. So we cannot define something as \u201cTarget would be matched, when Bob can access foo resource and do bar1 action or do bar2 action\u201d. Target AnyOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-regexp-match AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string foo /AttributeValue AttributeDesignator MustBePresent= false Category= urn:oasis:names:tc:xacml:3.0:attribute-category:resource AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / /Match Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar1 /AttributeValue AttributeDesignator MustBePresent= false Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /Match /AllOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar2 /AttributeValue AttributeDesignator MustBePresent= false Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /Match /AllOf /AnyOf /Target More Functions and Algorithms XACML3 has introduced new String functions such as: urn:oasis:names:tc:xacml:3.0:function:string-starts-with urn:oasis:names:tc:xacml:3.0:function:string-ends-with urn:oasis:names:tc:xacml:3.0:function:string-contains urn:oasis:names:tc:xacml:3.0:function:string-substring Some improvements to other functions such as: urn:oasis:names:tc:xacml:3.0:function:dayTimeDuration-equal urn:oasis:names:tc:xacml:3.0:function:yearMonthDuration-equal urn:oasis:names:tc:xacml:3.0:function:dateTime-add-dayTimeDuration Also improvements to existing combine algorithms (deny-overrides, permit-overrides, ordered-deny-overrides and ordered-permit-overrides) and new two combine algorithms for policy and rule combining. urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:permit-unless-deny Improvements in XPath New XPath data type is introduced with XACML 3.0. In XACML 2.0, XPath is defined as a String and cannot define the context that the namespace prefix is going to resolve. Also XPath based multiple decisions scheme is introduced with XACML 3.0. Improvement in XACML Request and Response As it is possible to define custom attribute categories, many types of attribute categories can be in the XACML 3.0 request. XACML 2.0 request can contain only subject, resource, environment or action categories. The XACML Response can contain additional data such as: Request attributes that are defined in the XACML response. Applicable policy ids for a given XACML request are defined in the XACML response. XACML 3.0 Multiple Decision Profile This is a useful profile that allows you to request more than one access control decision in a single XACML request context, and also allows you to request a single combined decision based on multiple individual decisions. The XACML 3.0 Multiple Decision Profile (MDP) is particularly useful in scenarios where the PEP needs to request decisions for multiple requests in one XACML request, and provides a considerable improvement in performance between the PEP and the PDP in such scenarios. For a set of tutorials that demonstrate how to work with XACML MDP requests in WSO2 Identity Server, see Working with XACML Multiple Decision Profile Requests . XACML 3.0 JSON Profile This is a new profile that provides a standardized interface between the PEP and the PDP using JSON. The decision request and response structure is specified in the core XACML specification. With the introduction of the XACML 3.0 JSON profile , WSO2 Identity Server supports the JSON format in addition to the default XML format with regard to XACML 3.0 requests and responses. Tip WSO2 Identity Server also supports working with XACML MDP requests and responses in JSON format . Following are some of the key points to keep in mind when you work with XACML 3.0 JSON requests and responses via WSO2 Identity Server: Certain parts of JSON requests and responses have default values to avoid bloating. For example, the default value of the data-type of an attribute should be string . The name of the XACML XML attribute element has changed to the category object in JSON so that it is possible to call the parent element. The AttributeValue element in the XML representation no longer exists. Instead a value property is introduced to the attribute object. The AdviceId and the ObligationId attributes of Advice/ and Obligation/ XML elements are renamed to Id in JSON. The order of objects and values in the serialized form (JSON) does not matter in XACML. You can use the short name of identifiers instead of the URI. Following are the supported identifier URIs and the short name for each: Identifier URI Short name urn:oasis:names xacml:3.0:attribute-category:resource Resource urn:oasis:names xacml:3.0:attribute-category:action Action urn:oasis:names xacml:3.0:attribute-category:environment Environment urn:oasis:names xacml:3.0:attribute-category:access-subject AccessSubject urn:oasis:names xacml:3.0:attribute-category:recipient-subject RecipientSubject urn:oasis:names xacml:3.0:attribute-category:intermediary-subject IntermediarySubject urn:oasis:names xacml:3.0:attribute-category:codebase Codebase urn:oasis:names xacml:3.0:attribute-category:requesting-machine RequestingMachine The JSON format supports the fully qualified XACML data-type URI, and also supports the short name of the data-type. XACML data type identifier JSON shorthand type code Mapping/inference rule http://www.w3.org/2001/XMLSchema#string string JSON \"String\" http://www.w3.org/2001/XMLSchema#boolean boolean JSON \"Boolean\" http://www.w3.org/2001/XMLSchema#integer integer JSON \"Number\" without a fractional portion, and within the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#double double JSON \"Number\" with a fractional portion, or out of the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#time time None. Inference must fail. http://www.w3.org/2001/XMLSchema#date date None. Inference must fail. http://www.w3.org/2001/XMLSchema#dateTime dateTime None. Inference must fail. http://www.w3.org/2001/XMLSchema#dayTimeDuration dayTimeDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema#yearMonthDuration yearMonthDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema#anyURI anyURI None. Inference must fail. http://www.w3.org/2001/XMLSchema#hexBinary hexBinary None. Inference must fail. http://www.w3.org/2001/XMLSchema#base64Binary base64Binary None. Inference must fail. urn:oasis:names xacml:1.0:data-type:rfc822Name rfc822Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:x500Name x500Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:ipAddress ipAddress None. Inference must fail. urn:oasis:names xacml:1.0:data-type:dnsName dnsName None. Inference must fail. urn:oasis:names xacml:1.0:data-type:xpathExpression xpathExpression None. Inference must fail. xpathExpression data-type values are represented as JSON objects, and each object contains the following properties: Attribute Type Required Default value XPathCategory URI Yes. You can use the short names defined for identifier URIs as values here. None Namespaces Array of namespace declarations No None XPath String Yes None The namespaces property should contain the following properties: Attribute Type Required Default value Prefix String No None Namespace URI Yes None Following is a sample JSON attribute format that contains the fully qualified XACML data-type URI: java { \"Attribute\": { \"AttributeId\": \"urn:oasis:names:tc:xacml:3.0:content-selector\", \"DataType\": \"xpathExpression\", \"Value\": { \"XPathCategory\": \"urn:oasis:names:tc:xacml:3.0:attribute-category:resource\", \"Namespaces\": [{ \"Namespace\": \"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\" }, { \"Prefix\": \"md\", \"Namespace\": \"urn:example:med:schemas:record\" }], \"XPath\":\"md:record/md:patient/md:patientDoB\" } } } The MultiRequests object is optional in the JSON representation of XACML. The purpose of the MultiRequests object is to support the XACML multiple decision profile. The JSON attribute object contains an array of attribute objects. The attribute object contains the following properties: Property name Type Required Default value AttributeId URI Yes None. The identifier used in the XML representation of a XACML attribute will be used in its JSON representation Value Either string, boolean, number (this maps to either a XACML integer or double as defined in supported data types), object, array of strings, array of boolean, Array of number, array of object, or a mixed array of string and number where the string values represents a numerical value. Yes None. Issuer String No Null Data Type URI No The data type value can be omitted in the JSON representation. The default value is http://www.w3.org/2001/XMLSchema#string . IncludeInResult Boolean No False The results of the JSON request is represented by the decision object in the form of a JSON Object. This can have following properties: Property name Type Required Default value Decision String Yes. Possible values are: Permit, Deny, NotApplicable, Indeterminate None. The results can have the status , obligations , associatedAdvice , category , and policyIdentifierList , which are optional. Following is a sample JSON request that you can try out with WSO2 Identity Server: { Request : { AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : sam , DataType : string , IncludeInResult : true } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , DataType : string , IncludeInResult : true } ] }, Action : { Attribute : [{ AttributeId : action-id , Value : modify-welcome , DataType : string , IncludeInResult : true } ] } } } Following is a sample XACML JSON response that you will get for the above request: { Response : [ { Decision : Deny , Status : { StatusCode : { Value : urn:oasis:names:tc:xacml:1.0:status:ok } }, AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : dinali , IncludeInResult : true , DataType : string } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , IncludeInResult : true , DataType : string } ] }, Action : { Attribute : [ { AttributeId : action-id , Value : modify-welcome , IncludeInResult : true , DataType : string } ] } } ] } For a tutorial that demonstrate how WSO2 IS supports fine-grained authorization using XACML requests in JSON format, see Fine-grained Authorization using XACML Requests in JSON Format . Administrative Delegation Profile This is also a new profile that comes with XACML 3.0. This allows you to define policies about who can write policies about what. For example, \u201cBob may issue a policy but only about resources in department X\u201d. XACML 2.0 and XACML 3.0 samples The biggest difference between XACML 2.0 and XACML 3.0 for your client app is that the structure of the attributes in the authentication request has changed significantly in XACML 3.0. In XACML 2.0, attributes were organized into subject, resource, environment, or action categories using XML element tags: Request xmlns= urn:oasis:names:tc:xacml:2.0:context:schema:os xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= urn:oasis:names:tc:xacml:2.0:context:schema:os access_control-xacml-2.0-context-schema-os.xsd Subject Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue Julius Hibbert /AttributeValue /Attribute /Subject Resource Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#anyURI AttributeValue http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Resource Action Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue read /AttributeValue /Attribute /Action Environment/ /Request In XACML 3.0, these categories are indicated using XML attributes instead of XML element tags: ?xml version= 1.0 encoding= utf-8 ? Request xsi:schemaLocation= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd ReturnPolicyIdList= false CombinedDecision= false xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance Attributes Category= urn:oasis:names:tc:xacml:1.0:subject-category:access-subject Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string Julius Hibbert /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:resource Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#anyURI http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:environment / /Request The Subject element in XACML 2.0 becomes Attributes Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\" in XACML 3.0, for example. This is the same for the resource, environment, and action categories.","title":"Access Control and Entitlement Management"},{"location":"key-concepts/access-control-and-entitlement-management/#access-control-and-entitlement-management","text":"Today, enterprise applications seek ways of enforcing security that allows the right people to access the right resources with restrictions enforced by enterprise policies. Identity and entitlement management systems, as a whole, attempt to address these security considerations. These systems help enterprise architects and developers in their application requirement implementations and try to significantly ease the burden of security-related implementations. These identity and entitlement management systems are governed by industry standard specifications, hence supporting security requirements for heterogeneous applications becomes easy. Click here for more information on Access control.","title":"Access Control and Entitlement Management"},{"location":"key-concepts/access-control-and-entitlement-management/#types-of-access-control","text":"The following table describes the various types of access control. Access Control Type Description Access Control Lists Access control lists are the oldest and most basic form of access control. This type was primarily adopted for use in operating systems. This maintains a set of users and operations that can be performed on a resource as a mapping. This is easy to implement due to the use of maps. However, this is not scalable for larger user bases and can become difficult to manage. Role-based Access Control Role-based Access Control (RBAC) is an approach used to restrict access to authorized users based on their role. This is a static permission model which provides access control. It is used by the majority of enterprises with more than 500 users. This access control type is used when all users are categorized into different roles. The roles define the resources that can be accessed by users assigned to that role. This type of access control reduces management overhead. These users and roles can also be externalized using user stores. These roles need to be managed carefully. There can be instances where a user is assigned to multiple roles. This is a subset of ABAC. Static permissions for roles can be given by updating permission tree in WSO2 Identity Server. Click here for information on Configuring roles and permissions. Attribute-based Access Control Attribute-based access control (ABAC) defines a new access control paradigm whereby access rights are granted to users through the use of policies that combine attributes together. Here, authorization happens based on attributes. This access control type addresses the limitations of role-based access control to provide a more fine-grained approach. This can be based on the attributes of the user, the environment, or even the resource itself. This is more flexible when compared with the role-based approach. There is no need to know the user prior to granting access. Policy-based Access Control This type of access control addresses the requirement to have a more uniform access control mechanism. This helps larger enterprises to have uniform access control for the large amount of organizational units. This is helpful when carrying out security audits. This is the most complex form of access control. This involves specifying policies unambiguously using XACML and using authorized attribute sources in the enterprise. Here Policy Based Access Control(PBAC) (also called Rule-based access control) is an extension of ABAC where attributes are used in writing policies.","title":"Types of access control"},{"location":"key-concepts/access-control-and-entitlement-management/#introducing-xacml","text":"XACML (eXtensible Access Control Markup Language) is an XML-based language for access control that has been standardized by the Technical Committee of the OASIS consortium. XACML is popular as a fine grain authorization method among the community. However, there are aspects of XACML that surpasses other policy standards by being a fine-grained authorization mechanism. Although XACML was introduced as a standard by OASIS in 2003, not many organizations that have adopted it yet. This is because most organization's lack of interest in moving towards a XACML based solution for authorization. The following can be some of the reasons for this: Many software designer and developers lack a clear understanding of features, importance, and advantages of XACML. It is comparatively difficult to implement a XACML solution when compared with a typical JDBC or hard-coded authorization system. Performance of XACML-based authorization system may be less than adequate. The complexity of defining and managing XACML policies. However, current market trends indicate that there is some motivation for XACML-based authorization systems. This section includes some architectural and implementation details on XACML with an existing XACML engine. To summarize, XACML describes both an access control policy language, request/response language, and reference architecture. The policy language is used to express access control policies (who can do what, when). The request/response language expresses queries about whether a particular access should be allowed (requests) and describes answers to those queries(responses). The reference architecture proposes a standard for deployment of necessary software modules within an infrastructure to allow efficient enforcement of policies. WSO2 Identity Server uses XACML as a tool for controlling access to applications. Recommended reading For more information on XACML specifications and other related information, see the OASIS website .","title":"Introducing XACML"},{"location":"key-concepts/access-control-and-entitlement-management/#why-xacml","text":"Most of the organizations still use legacy systems with inbuilt authorization logic. Sometimes, one organization contains a large number of information systems and applications that each system or application uses for their own process for authorization. Today, authorization has become more complex because users within organizations and outside need access to shared data and have the need to collaborate efficiently. Therefore, this has been challenging task to manage these legacy systems, custom authorization systems. However, XACML offers a solution to this problem. Most traditional authorization systems mostly have the following features: Authorization logic is hard-coded into the source code. Authorization logic is stored in databases that could only be readable and understandable by the underlying application The following are the some goals that current organizations are looking at from an authorization system. Can business managers (who should determine how access controls would be implemented) define and modify different authorization logic? Can we find new IT technicians to manage these legacy systems? Especially when those who developed the system have left the organization? Can different authorization logic be modified without any source code changes in a dynamic way? Is authorization system capable of evaluating following rule? \u201cX resource can be accessed by the Users who are from example.com domain and whose age is greater than 21 years old\u201d If we are going to implement a new information system with the organization, can we re-use the authorization logic of a legacy system? Can we achieve a fine-grained authorization level without defining a large number of static combinations? Are the authorization systems capable of answering the questions such as: \u201cCan a user, Bob, transfer X amount from Y current account at 1.00pm?\u201c Clearly, the above goals cannot be achieved from a traditional authorization system. However, a XACML-based authorization solution can help to achieve all of these goals, because XACML: is a standard which is ratified by OASIS standards organization. is a policy language implemented using XML which is an industry standard. supports Attribute-based Access Control (ABAC) and evaluation can be done with the additional data retrieved from Policy Information Point (PIP) which is defined by the XACML reference architecture. Note","title":"Why XACML"},{"location":"key-concepts/access-control-and-entitlement-management/#attribute-based-access-controlabac","text":"ABAC is an access control paradigm whereby access rights are granted to users through the use of policies which combine attributes together. The policies can use any type of attributes (user attributes, resource attributes, object, environment attributes etc.). This model supports boolean logic , in which rules contain \"IF, THEN\" statements about who is making the request, the resource, and the action. For example: IF the requestor is a manager, THEN allow read/write access to sensitive data. contains reference architecture which is provided to externalize the authorization system. The Policy Decision Point (PDP) offers authorization as a service in your infrastructure. Authorization algorithms can be removed from the application logic and applications can query the PDP via their own Policy Enforcement Points (PEP). provides fine-grained authorization with higher level of abstraction by means of policies and rules. supports dynamic evaluation of policies by using the Policy Information Point (PIP). can publish multiple policies into external PDPs.","title":"Attribute-based Access Control(ABAC)"},{"location":"key-concepts/access-control-and-entitlement-management/#xacml-system-architecture","text":"Policy Decision Point (PDP) evaluates policies against access requests provided by Policy Enforcement Points (PEP). To provide the decisions, PDP may also need to query a Policy Information Point (PIP) to gather descriptive attributes about the user or any other missing attribute in the request. Policy Administration Point (PAP) is used to manage the PDP and PIP functionality.","title":"XACML system architecture"},{"location":"key-concepts/access-control-and-entitlement-management/#xacml-terminology","text":"The XACML reference architecture illustrated above is comprised of the following four 'building blocks'. Policy Enforcement Point (PEP) : The system entity that performs access control by making decision requests and enforcing authorization decisions. This is the entity that sends the XACML request to the Policy Decision Point (PDP) and receives an authorization decision. Policy Decision Point (PDP) : The system entity that evaluates an applicable policy and returns an authorization decision. Policy Information Point (PIP) : The system entity that acts as a source of attribute values. If there are missing attributes in the XACML request that is sent by PEP, PIP would find them for the PDP to evaluate the policy. Policy Administration Point (PAP) : The system entity that creates a policy or policy set and manages them.","title":"XACML terminology"},{"location":"key-concepts/access-control-and-entitlement-management/#xacml-engine-architecture","text":"The WSO2 Identity Server is a major player in the XACML and open source world. The Identity Server supports XACML 3.0, which is based on Balana XACML implementation . As the source code, distribution and documentation are available for free, it is possible to analyze and understand the architecture behind it. You can find source code from here . This section provides some information regarding the architecture of the XACML engine (or the entitlement engine) of the WSO2 Identity Server. The XACML engine of the WSO2 Identity Server has two major components, i.e., PAP and PDP. The section below focuses on Policy Decision Point (PDP). The following diagram represents the component architecture of the PDP. The following provides a more detailed information on the various components available in the PDP architecture. Entitlement Admin Service All PDP configurations are exposed via this API as a Web service which you need to have certain privileges to access. The following functions can be done by calling this API. Invalidating caches Refreshing policy, attribute, resource finder modules Retrieving PDP configurations Includes the function for testing the Test PDP with a given sample request or a sample request with given policies Entitlement Service Actual XACML authorization API is exposed via this API as a Web service. This service supports the following three communication methods with PEP. SOAP-based Web service Thrift binary protocol (this is much faster than SOAP) WS-XACML (This is the standard way but not popular) Balana PDP This is the core of the engine. Balana PDP has been initialized with all the attribute finders, resource finders and policy finder modules that are plugged with WSO2 Identity Server. Balana Test PDP This is same as Balana PDP. However, this instance has been initialized with the PAP policy store. It means, policies that are defined by PAP can be evaluated by using this PDP instance. There is no policy caching or decision caching with this. Therefore, this can only be used for testing your policies in the PAP store. Web service API for Balana Test PDP is exposed via the Entitlement Admin Service with method name \u201cdoTestRequest()\u201d. Carbon Policy Finder This module finds policies from different policy stores to evaluate a XACML request. The following is a high-level diagram of how this works. Any number of policy finder modules can be plugged with the Carbon policy finder. You need to implement the CarbonPolicyFinderModule interface to write a new module and register it using the configuration file called entitlement.properties.xml in IS_HOME /repository/components/features/org.wso2.carbon.identity.xacml.server_5.8.145 directory . By default, WSO2 Identity Server is shipped with a Carbon registry-based policy finder module that can retrieve policies from a registry collection, where the collection path is configurable using a property value in the entitlement.properties.xml file. All modules are initialized and policies are loaded into memory when the Carbon policy finder is used. Loaded policies are kept as a policy collection where you can use your own implementation to access them. A written policy collection implementation can be registered using the entitlement.properties.xml file. The default implementation uses an in-memory cache and creates an effective policy for a given XACML request. Therefore, the Carbon policy finder always finds effective policies from the policy collection where it is recommended to be kept in-memory. However, if any update in the policy store happens, the Carbon policy finder can be re-initialized automatically by the module that you have written, or you can re-initialize it by using the Web service API (Entitlement Admin Service). Alternatively, you can do it manually using the Identity Server Management Console. When you are writing a new module, you need to consider the following in addition to policy retrieving and re-initializing. Policy ordering - The order which policies are evaluated. Policy combining algorithm Note There are Policy Combining Algorithms which are used by Policy Sets and Rule Combining Algorithms which are used by Policies . Each of the algorithms mentioned below has its Policy Combining algorithm and its Rule Combining algorithms as follows: Standard combining algorithms defined in XACML 3.0: urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-overrides urn:oasis:names xacml:1.0:rule-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:first-applicable urn:oasis:names xacml:1.0:policy-combining-algorithm:only-one-applicable urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-deny-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:policy-combining-algorithm:ordered-permit-overrides urn:oasis:names xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names xacml:3.0:policy-combining-algorithm:permit-unless-deny These algorithms are explained in detail as follows, Deny Overrides: This combining algorithm combines decisions in such a way that if any decision is a Deny, then that decision wins. Deny overrides is one of the safest combining algorithms since it favors a Deny decision. However, if none of the children return a Deny decision, then the combining algorithm will never produce a Deny. Permit Overrides: This combining algorithm combines decisions in such a way that if any decision is a Permit, then that decision wins. The permit overrides combining algorithm can be interesting when: At least one child must return a Permit for access to be granted overall regardless of restrictions. One wants to return all the reasons why access is being denied. This is what one could call a \u201cgreedy deny overrides\u201d.Forinstanceifthe reason for not being able to view a resource is that(a) you are not the owner and (b) you are in the wrong department, then we could rework the previous example as follows. When any of the deny reason triggers, the response would be denied with all the applicable reasons for access being denied: Policy Set (deny overrides): role==manager AND action==view AND resourceType==resource - Policy 1 (permit overrides) - Rule 1: deny if resourceOwner != userId + Advice(\u201cyou are not the owner of the resource\u201d) - Rule 2: deny if rsourceDepartment != userDepartment+ Advice(\u201cyou are not in the same department as the resource) - Policy 2 - Rule 1: permit First Applicable: This combining algorithm combines decisions in such a way that the final decision returned is the first one produced either of Permit or Deny. ** ** First applicable is useful to shortcut policy evaluation. For instance, if a policy set contains a long series of not applicable policies and one applicable policy which returns either of Permit or Deny, then if that policy comes first and does produce Permit or Deny, the PDP will stop there and not process the other siblings. Deny Unless Permit | Permit Unless Deny: In XACML there are 4 possible decisions: Permit, Deny, NotApplicable, and Indeterminate. Sometimes, it is desirable to hide the NotApplicable and Indeterminate decisions to only allow for Permit or Deny. It makes the PEP logic potentially simpler. Only One Applicable: This combining algorithm exists only for policy sets to combine policy sets and policies. It cannot be used to combine rules. With this combining algorithm, in order for either of a Permit or Deny to be returned, then only one of the children must produce a valid decision \u2013 whether Deny or Permit. Ordered Deny Overrides | Ordered Permit Overrides: The ordered combining algorithms combine decisions in the same way as their (unordered) cousins. In, addition they bring the guarantee that policies, policy sets, and rules are considered in the order in which they are defined. The need to define an ordered combining algorithm stems from the fact the XACML specification does not specify whether order matters in the deny-overrides and permit-overrides combining algorithms. How to retrieve referenced policies Carbon Attribute Finder This module helps to find the missing attribute for a given XACML request. The following is the high-level diagram for both the Carbon attribute and resource finders. Any number of PIP attribute finder modules can be plugged with the Carbon attribute finder. You need to implement the PIPAttributeFinder interface to write a new module and register it using the entitlement.properties configuration file. By default, WSO2 Identity Server is shipped with a DefaultAttributeFinder that communicates with the underlying user store of the Identity Server. The default user store of the Identity Server is ApacheDS where it can be changed using user-mgt.xml file. See Configuring the Realm for more information. All modules would be initialized and supported attribute Ids are retrieved for each module. During runtime, the Carbon attribute finder checks for the support attribute Id and hands it over to the proper module to handle. A caching machine is used by the Carbon attribute finder for caching the findings or the attribute finder module itself can handle it. Carbon Resource Finder This is used to retrieve children or descendant resources of a given root level resource value. Basically, it is used to fulfill the requirement of a multiple decision profile. The implementation is same as the PIP attribute finder module. By default, WSO2 Identity Server is shipped with DefaultResourceFinder (which is the implementation of PIPResourceFinder) that communicates with Carbon registry resources.","title":"XACML engine architecture"},{"location":"key-concepts/access-control-and-entitlement-management/#xacml-policy-language-structure-and-syntax","text":"In order to render an authorization decision , it is possible to combine the two separate policies to form the single policy applicable to the request. XACML defines three top-level policy elements: Element that contains a boolean expression that can be evaluated in isolation, but that is not intended to be accessed in isolation by a PDP . So, it is not intended to form the basis of an authorization decision by itself. It is intended to exist in isolation only within an XACML PAP , where it may form the basic unit of management. Element that contains a set of elements and a specified procedure for combining the results of their evaluation. It is the basic unit of policy used by the PDP , and so it is intended to form the basis of an authorization decision. Element that contains a set of or other elements and a specified procedure for combining the results of their evaluation. It is the standard means for combining separate policies into a single combined policy . As XACML is used in Attribute-based Access Controlling, in XACML all the attributes are categorized into the following four main categories: But from XACML 3.0, custom categories are also supported. Subject Resource Action Environment A Rule is the most elementary unit of policy . It may exist in isolation only within one of the major actors of the XACML domain. The main components of a Rule are as follows: This defines the set of requests to which the rule is intended to apply in the form of a logical expression on attributes in the request. The effect of the rule indicates the rule -writer's intended consequence of a \"True\" evaluation of the rule . Two values are allowed: \"Permit\" and \"Deny\". A Boolean expression that refines the applicability of the rule beyond the predicates implied by its target . Therefore, it may be absent. Obligation expressions may be added by the writer of the policy. When a PDP evaluates a policy containing obligation expressions, it evaluates the obligation expressions into obligations and returns certain of those obligations to the PEP in the response context. AttributeSelector - This allows the policy to specify an attribute with given identifier, category and data type. The AttributeSelector on the other hand, provides a mean to lookup the value of attributes using a XPath query by specifying the data type and XPath expression. Attribute selectors are then executed against the XML content that may have been sent along in the initial XACML request. A sample XACML 3.0 policy is as follows: Policy xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 PolicyId= samplePolicy RuleCombiningAlgId= urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-overrides Version= 1.0 Target AnyOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue AttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action DataType= http://www.w3.org/2001/XMLSchema#string MustBePresent= true / /Match /AllOf /AnyOf /Target Rule Effect= Permit RuleId= permit / /Policy","title":"XACML policy language structure and syntax"},{"location":"key-concepts/access-control-and-entitlement-management/#improvements-in-xacml-30","text":"The XACML 3.0 core specification highlights the following main changes in comparison with XACML 2.0.","title":"Improvements in XACML 3.0"},{"location":"key-concepts/access-control-and-entitlement-management/#custom-attribute-categories","text":"Custom attribute categories can be defined with XACML 3.0. However, in XACML 2.0, attributes have been organized into subject, resource, environment or action. For instance, lets's say that you want to create an attribute category called \u201cfoo\u201d in your policy and request. You can do it with XACML 3.0 easily. According to the XACML 3.0 policy schema, the category of XACML element is identified by a XML attribute called \u201c Category \u201d. In XACML 2.0 Policy, you can define the attribute designator element as follows, However, it must be a pre-defined category such as subject, resource, environment or action. ResourceAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / In a XACML 3.0 Policy, you can define it as follows. Category can be anything as it is defined as an attribute of the AttributeDesignator element. AttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id Category= resource DataType= http://www.w3.org/2001/XMLSchema#string /","title":"Custom attribute categories"},{"location":"key-concepts/access-control-and-entitlement-management/#improvements-in-obligation","text":"In general, obligations can have the following: An Obligation has an identifier, which is used to distinguish different types of obligations An Obligation can have arguments Obligations apply to Permit (or Deny) decisions only A PDP will return, as part of a Permit or Deny response, a (possibly empty) subset of the obligations that appear in the policy. There are several improvements with Obligations in XACML 3.0 when compared to 2.0. One of the main improvements is the introduction of Obligation Expressions . This adds dynamic expressions into the obligation statements. For a more in-depth understanding, see the following example: Let's assume that you want to do following with the Obligation: \u201cOn deny, inform the PEP to send an email to the user\u201d. In XACML 2.0, you need to define the obligation element with the user email statically. Obligation ObligationId= send-email FulfillOn= Deny AttributeAssignment AttributeId= email DataType= http://www.w3.org/2001/XMLSchema#string user@foo.com /AttributeAssignment /Obligation However, the user may not be same for each XACML request that is evaluated. Therefore it is not possible to configure the email statically in the Obligation element. Obligation can only inform PEP to send an email to user (it lets the PEP figure out the value of user\u2019s email). Obligation ObligationId= send-email FulfillOn= Deny AttributeAssignment AttributeId= text DataType= http://www.w3.org/2001/XMLSchema#string please send email to user /AttributeAssignment /Obligation However, in XACML 3.0, the email of each user can be retrieved using PIP in dynamically as we can define an expression element inside the ObligationExpression . Therefore, obligation can inform PEP to send an email to address. ObligationExpression ObligationId= send-email FulfillOn= Deny AttributeAssignmentExpression AttributeId= email DataType= http://www.w3.org/2001/XMLSchema#string AttributeDesignator AttributeId= email Category= urn:oasis:names:tc:xacml:1.0:subject-category:access-subject DataType= http://www.w3.org/2001/XMLSchema#string MustBePresent= false / /AttributeAssignmentExpression /ObligationExpression In XACML 2.0, obligations can only be added to policies and policy sets. However, with XACML 3.0, rules can also contain obligations. At the root of all XACML policies, is a policy or a policy set . A policy represents a single access control policy, expressed through a set of rules. A policy set is a container that can hold other policies or policy sets, as well as references to policies found in remote locations.","title":"Improvements in Obligation"},{"location":"key-concepts/access-control-and-entitlement-management/#introducing-advice","text":"Advice is a newly introduced feature with XACML 3.0. Advice is similar to obligations and it shares much of its syntax. The difference is contractual: the PEP can disregard any advice it receives. PEPs do not have to comply with advice statements; PEPs can consider or discard the statement. A common scenario is to explain why something was denied: \u201cUser bob is denied because he does not have a valid email\u201d. The XACML specification says that any advice returned with a decision can be safely ignored by compliant PEPs. This means that PEPs should work as described in the previous section, regardless of what the PEP does with the advice it may receive. For example, a PEP must allow access if it receives a Permit decision with no obligations, regardless of any advice in the decision.","title":"Introducing Advice"},{"location":"key-concepts/access-control-and-entitlement-management/#improvements-in-target","text":"Since it is possible to define custom attribute categories, there are improvements in some related elements in the XACML 3.0 policy, when compared to 2.0. With XACML 3.0, the Target element can be used to define more complex authorization logic within itself when compared with 2.0. In XACML 2.0, the Target element contains the OR and AND relationship between the same category. However, in XACML 3.0, AllOf and AnyOf elements have been introduced to Target element. That clearly helps to define the OR and AND relationship between different categories. As an example, let's look at a Target element. In XACML 2.0, we have an AND relationship between foo1 and foo2 resources and an OR relationship between bar1 and bar2 actions. However, we cannot create an OR relationship between a foo1 resource and bar1 action. so we cannot define something such as \u201cTarget would be matched when Bob can access the foo resource or do a bar action\u201d by using the Target element. Target Resources Resource ResourceMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string foo1 /AttributeValue ResourceAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / /ResourceMatch ResourceMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string foo2 /AttributeValue ResourceAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / /ResourceMatch /Resource /Resources Actions Action ActionMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar1 /AttributeValue ActionAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /ActionMatch /Action Action ActionMatch MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar2 /AttributeValue ActionAttributeDesignator AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /ActionMatch /Action /Actions /Target XACML 3.0 has an AND relationship between \u201c foo \u201d resource and \u201c bar1 \u2033 role and an OR relationship between \u201c bar2 \u2033 action. So we cannot define something as \u201cTarget would be matched, when Bob can access foo resource and do bar1 action or do bar2 action\u201d. Target AnyOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-regexp-match AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string foo /AttributeValue AttributeDesignator MustBePresent= false Category= urn:oasis:names:tc:xacml:3.0:attribute-category:resource AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#string / /Match Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar1 /AttributeValue AttributeDesignator MustBePresent= false Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /Match /AllOf AllOf Match MatchId= urn:oasis:names:tc:xacml:1.0:function:string-equal AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string bar2 /AttributeValue AttributeDesignator MustBePresent= false Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string / /Match /AllOf /AnyOf /Target","title":"Improvements in Target"},{"location":"key-concepts/access-control-and-entitlement-management/#more-functions-and-algorithms","text":"XACML3 has introduced new String functions such as: urn:oasis:names:tc:xacml:3.0:function:string-starts-with urn:oasis:names:tc:xacml:3.0:function:string-ends-with urn:oasis:names:tc:xacml:3.0:function:string-contains urn:oasis:names:tc:xacml:3.0:function:string-substring Some improvements to other functions such as: urn:oasis:names:tc:xacml:3.0:function:dayTimeDuration-equal urn:oasis:names:tc:xacml:3.0:function:yearMonthDuration-equal urn:oasis:names:tc:xacml:3.0:function:dateTime-add-dayTimeDuration Also improvements to existing combine algorithms (deny-overrides, permit-overrides, ordered-deny-overrides and ordered-permit-overrides) and new two combine algorithms for policy and rule combining. urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:deny-unless-permit urn:oasis:names:tc:xacml:3.0:rule-combining-algorithm:permit-unless-deny urn:oasis:names:tc:xacml:3.0:policy-combining-algorithm:permit-unless-deny","title":"More Functions and Algorithms"},{"location":"key-concepts/access-control-and-entitlement-management/#improvements-in-xpath","text":"New XPath data type is introduced with XACML 3.0. In XACML 2.0, XPath is defined as a String and cannot define the context that the namespace prefix is going to resolve. Also XPath based multiple decisions scheme is introduced with XACML 3.0.","title":"Improvements in XPath"},{"location":"key-concepts/access-control-and-entitlement-management/#improvement-in-xacml-request-and-response","text":"As it is possible to define custom attribute categories, many types of attribute categories can be in the XACML 3.0 request. XACML 2.0 request can contain only subject, resource, environment or action categories. The XACML Response can contain additional data such as: Request attributes that are defined in the XACML response. Applicable policy ids for a given XACML request are defined in the XACML response.","title":"Improvement in XACML Request and Response"},{"location":"key-concepts/access-control-and-entitlement-management/#xacml-30-multiple-decision-profile","text":"This is a useful profile that allows you to request more than one access control decision in a single XACML request context, and also allows you to request a single combined decision based on multiple individual decisions. The XACML 3.0 Multiple Decision Profile (MDP) is particularly useful in scenarios where the PEP needs to request decisions for multiple requests in one XACML request, and provides a considerable improvement in performance between the PEP and the PDP in such scenarios. For a set of tutorials that demonstrate how to work with XACML MDP requests in WSO2 Identity Server, see Working with XACML Multiple Decision Profile Requests .","title":"XACML 3.0 Multiple Decision Profile"},{"location":"key-concepts/access-control-and-entitlement-management/#xacml-30-json-profile","text":"This is a new profile that provides a standardized interface between the PEP and the PDP using JSON. The decision request and response structure is specified in the core XACML specification. With the introduction of the XACML 3.0 JSON profile , WSO2 Identity Server supports the JSON format in addition to the default XML format with regard to XACML 3.0 requests and responses. Tip WSO2 Identity Server also supports working with XACML MDP requests and responses in JSON format . Following are some of the key points to keep in mind when you work with XACML 3.0 JSON requests and responses via WSO2 Identity Server: Certain parts of JSON requests and responses have default values to avoid bloating. For example, the default value of the data-type of an attribute should be string . The name of the XACML XML attribute element has changed to the category object in JSON so that it is possible to call the parent element. The AttributeValue element in the XML representation no longer exists. Instead a value property is introduced to the attribute object. The AdviceId and the ObligationId attributes of Advice/ and Obligation/ XML elements are renamed to Id in JSON. The order of objects and values in the serialized form (JSON) does not matter in XACML. You can use the short name of identifiers instead of the URI. Following are the supported identifier URIs and the short name for each: Identifier URI Short name urn:oasis:names xacml:3.0:attribute-category:resource Resource urn:oasis:names xacml:3.0:attribute-category:action Action urn:oasis:names xacml:3.0:attribute-category:environment Environment urn:oasis:names xacml:3.0:attribute-category:access-subject AccessSubject urn:oasis:names xacml:3.0:attribute-category:recipient-subject RecipientSubject urn:oasis:names xacml:3.0:attribute-category:intermediary-subject IntermediarySubject urn:oasis:names xacml:3.0:attribute-category:codebase Codebase urn:oasis:names xacml:3.0:attribute-category:requesting-machine RequestingMachine The JSON format supports the fully qualified XACML data-type URI, and also supports the short name of the data-type. XACML data type identifier JSON shorthand type code Mapping/inference rule http://www.w3.org/2001/XMLSchema#string string JSON \"String\" http://www.w3.org/2001/XMLSchema#boolean boolean JSON \"Boolean\" http://www.w3.org/2001/XMLSchema#integer integer JSON \"Number\" without a fractional portion, and within the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#double double JSON \"Number\" with a fractional portion, or out of the integer range defined by the XML schema in [XMLDatatypes] http://www.w3.org/2001/XMLSchema#time time None. Inference must fail. http://www.w3.org/2001/XMLSchema#date date None. Inference must fail. http://www.w3.org/2001/XMLSchema#dateTime dateTime None. Inference must fail. http://www.w3.org/2001/XMLSchema#dayTimeDuration dayTimeDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema#yearMonthDuration yearMonthDuration None. Inference must fail. http://www.w3.org/2001/XMLSchema#anyURI anyURI None. Inference must fail. http://www.w3.org/2001/XMLSchema#hexBinary hexBinary None. Inference must fail. http://www.w3.org/2001/XMLSchema#base64Binary base64Binary None. Inference must fail. urn:oasis:names xacml:1.0:data-type:rfc822Name rfc822Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:x500Name x500Name None. Inference must fail. urn:oasis:names xacml:1.0:data-type:ipAddress ipAddress None. Inference must fail. urn:oasis:names xacml:1.0:data-type:dnsName dnsName None. Inference must fail. urn:oasis:names xacml:1.0:data-type:xpathExpression xpathExpression None. Inference must fail. xpathExpression data-type values are represented as JSON objects, and each object contains the following properties: Attribute Type Required Default value XPathCategory URI Yes. You can use the short names defined for identifier URIs as values here. None Namespaces Array of namespace declarations No None XPath String Yes None The namespaces property should contain the following properties: Attribute Type Required Default value Prefix String No None Namespace URI Yes None Following is a sample JSON attribute format that contains the fully qualified XACML data-type URI: java { \"Attribute\": { \"AttributeId\": \"urn:oasis:names:tc:xacml:3.0:content-selector\", \"DataType\": \"xpathExpression\", \"Value\": { \"XPathCategory\": \"urn:oasis:names:tc:xacml:3.0:attribute-category:resource\", \"Namespaces\": [{ \"Namespace\": \"urn:oasis:names:tc:xacml:3.0:core:schema:wd-17\" }, { \"Prefix\": \"md\", \"Namespace\": \"urn:example:med:schemas:record\" }], \"XPath\":\"md:record/md:patient/md:patientDoB\" } } } The MultiRequests object is optional in the JSON representation of XACML. The purpose of the MultiRequests object is to support the XACML multiple decision profile. The JSON attribute object contains an array of attribute objects. The attribute object contains the following properties: Property name Type Required Default value AttributeId URI Yes None. The identifier used in the XML representation of a XACML attribute will be used in its JSON representation Value Either string, boolean, number (this maps to either a XACML integer or double as defined in supported data types), object, array of strings, array of boolean, Array of number, array of object, or a mixed array of string and number where the string values represents a numerical value. Yes None. Issuer String No Null Data Type URI No The data type value can be omitted in the JSON representation. The default value is http://www.w3.org/2001/XMLSchema#string . IncludeInResult Boolean No False The results of the JSON request is represented by the decision object in the form of a JSON Object. This can have following properties: Property name Type Required Default value Decision String Yes. Possible values are: Permit, Deny, NotApplicable, Indeterminate None. The results can have the status , obligations , associatedAdvice , category , and policyIdentifierList , which are optional. Following is a sample JSON request that you can try out with WSO2 Identity Server: { Request : { AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : sam , DataType : string , IncludeInResult : true } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , DataType : string , IncludeInResult : true } ] }, Action : { Attribute : [{ AttributeId : action-id , Value : modify-welcome , DataType : string , IncludeInResult : true } ] } } } Following is a sample XACML JSON response that you will get for the above request: { Response : [ { Decision : Deny , Status : { StatusCode : { Value : urn:oasis:names:tc:xacml:1.0:status:ok } }, AccessSubject : { Attribute : [ { AttributeId : subject-id , Value : dinali , IncludeInResult : true , DataType : string } ] }, Resource : { Attribute : [ { AttributeId : resource-id , Value : index.jsp , IncludeInResult : true , DataType : string } ] }, Action : { Attribute : [ { AttributeId : action-id , Value : modify-welcome , IncludeInResult : true , DataType : string } ] } } ] } For a tutorial that demonstrate how WSO2 IS supports fine-grained authorization using XACML requests in JSON format, see Fine-grained Authorization using XACML Requests in JSON Format .","title":"XACML 3.0 JSON Profile"},{"location":"key-concepts/access-control-and-entitlement-management/#administrative-delegation-profile","text":"This is also a new profile that comes with XACML 3.0. This allows you to define policies about who can write policies about what. For example, \u201cBob may issue a policy but only about resources in department X\u201d.","title":"Administrative Delegation Profile"},{"location":"key-concepts/access-control-and-entitlement-management/#xacml-20-and-xacml-30-samples","text":"The biggest difference between XACML 2.0 and XACML 3.0 for your client app is that the structure of the attributes in the authentication request has changed significantly in XACML 3.0. In XACML 2.0, attributes were organized into subject, resource, environment, or action categories using XML element tags: Request xmlns= urn:oasis:names:tc:xacml:2.0:context:schema:os xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= urn:oasis:names:tc:xacml:2.0:context:schema:os access_control-xacml-2.0-context-schema-os.xsd Subject Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue Julius Hibbert /AttributeValue /Attribute /Subject Resource Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id DataType= http://www.w3.org/2001/XMLSchema#anyURI AttributeValue http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Resource Action Attribute AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id DataType= http://www.w3.org/2001/XMLSchema#string AttributeValue read /AttributeValue /Attribute /Action Environment/ /Request In XACML 3.0, these categories are indicated using XML attributes instead of XML element tags: ?xml version= 1.0 encoding= utf-8 ? Request xsi:schemaLocation= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 http://docs.oasis-open.org/xacml/3.0/xacml-core-v3-schema-wd-17.xsd ReturnPolicyIdList= false CombinedDecision= false xmlns= urn:oasis:names:tc:xacml:3.0:core:schema:wd-17 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance Attributes Category= urn:oasis:names:tc:xacml:1.0:subject-category:access-subject Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:subject:subject-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string Julius Hibbert /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:resource Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:resource:resource-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#anyURI http://medico.com/record/patient/BartSimpson /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:action Attribute IncludeInResult= false AttributeId= urn:oasis:names:tc:xacml:1.0:action:action-id AttributeValue DataType= http://www.w3.org/2001/XMLSchema#string read /AttributeValue /Attribute /Attributes Attributes Category= urn:oasis:names:tc:xacml:3.0:attribute-category:environment / /Request The Subject element in XACML 2.0 becomes Attributes Category=\"urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\" in XACML 3.0, for example. This is the same for the resource, environment, and action categories.","title":"XACML 2.0 and XACML 3.0 samples"},{"location":"key-concepts/identity-anti-patterns-and-the-identity-bus/","text":"Identity Anti-patterns and the Identity Bus This topic explores the problem of identity anti-patterns and the solution provided by the WSO2 Identity Server in the form of the identity bus. Spaghetti identity and federation silos According to research conducted by the analyst firm, Quocirca , many businesses now have more external users than internal ones. Also many businesses are involved in acquisitions, mergers and partnerships, and these result in lots of external users joining the business. Often, these external users have to be integrated with the existing user base in bulk. This sort of integration can be complicated due to the different protocols followed by different identity systems. How this impacts enterprise identity management When working with both external and internal users and merging different systems together, you are faced with technicalities related to management of multiple heterogeneous user stores, different types of authentication protocols, legacy systems and many more. SAML, OpenID Connect, and WS-Federation all support identity federation and cross domain authentication. However, in a real world scenario, not all involved parties in a federation use case will support SAML and OpenID Connect. Most of the federation systems seen today are in silos. It can be a silo of SAML federation or a silo of OpenID Connect federation. While a system that uses SAML as it's protocol may be able to communicate with other SAML protocol-based systems, they may not be able to communicate with OpenID Connect. The diagram below illustrates how a silo of SAML federation and OpenID Connect federation interact within the respective silo and how it cannot interact with different silos. Also consider the scalability of a specific federation silo. Within the SAML federation silo, for example, there can be an increasing number of service providers and identity providers. Each service provider has to trust each identity provider and this leads to the Spaghetti Identity anti-pattern. The following diagram depicts the complexity of this. The identity bus Federation Silos and Spaghetti Identity are two anti-patterns directly addressed by the Identity Bus pattern in the WSO2 Identity Server. With Identity Bus, a given service provider is not coupled to a given identity provider and also not coupled to a given federation protocol. A user should be able to log into a service provider that accepts only SAML 2.0 tokens with an identity provider that issues only OpenID Connect tokens. The Identity Bus acts as a middle-man, or an Identity Broker, that mediates and transforms identity tokens between heterogeneous identity protocols. The following are some of the benefits of using the Identity Bus pattern. Introducing a new service provider is extremely easy. You only need to register the service provider in the Identity Bus and pick which identity providers it trusts. It is not necessary to add the service provider configuration to each and every identity provider. Similarly, removing an existing service provider is extremely easy. You only need to remove the service provider from the Identity Bus. It is not necessary to remove the service provider from each and every identity provider. Introducing a new identity provider is extremely easy. You only need to register the identity provider in the Identity Bus. It will be available for any service provider. Similarly, removing an existing identity provider is extremely easy. You only need to remove the identity provider from the Identity Bus. Enforcing new authentication protocols is extremely easy. Consider a scenario where you need to authenticate users with both the username and password and also Duo Security (SMS based authentication). To do this, you only need to add that capability to the Identity Bus and pick the required set of authentication protocols against a given service provider at the time of service provider registration. In the Identity Bus, each service provider can be configured based on how it authenticates users. Claim transformations. Your service provider may read user's email address from the \" http://sp1.org/claims/email \" attribute id - but the identity provider of the user may send it as \" http://idp1.org/claims/emai \" . Identity bus can transform the claims it receives from the identity provider to the format expected by the service provider. Role mapping. Your service provider needs to authorize users once they are logged in. What the user can do at the identity provider is different from what the same user can do at the service provider. User's roles from the identity provider define what he can do at the identity provider. Service provider's roles define the things a user can do at the service provider. Identity bus is capable of mapping identity provider's roles to the service provider's roles. For example a user may bring idp-admin role from his identity provider - in a SAML response - then the identity bus will find the mapped service provider role corresponding to this, say sp-admin, and will add that into the SAML response returning back to the service provider from the identity bus. Just-in-time provisioning. Since identity bus is at the middle of all identity transactions - it can provision all external user identities to an internal user store. Centralized monitoring and auditing. Introducing a new federation protocol needs minimal changes. If you have a service provider or an identity provider, which supports a proprietary federation protocol, then you only need to add that capability to the identity bus. No need to implement it at each and every identity provider or service provider.","title":"Identity Anti patterns and the Identity Bus"},{"location":"key-concepts/identity-anti-patterns-and-the-identity-bus/#identity-anti-patterns-and-the-identity-bus","text":"This topic explores the problem of identity anti-patterns and the solution provided by the WSO2 Identity Server in the form of the identity bus.","title":"Identity Anti-patterns and the Identity Bus"},{"location":"key-concepts/identity-anti-patterns-and-the-identity-bus/#spaghetti-identity-and-federation-silos","text":"According to research conducted by the analyst firm, Quocirca , many businesses now have more external users than internal ones. Also many businesses are involved in acquisitions, mergers and partnerships, and these result in lots of external users joining the business. Often, these external users have to be integrated with the existing user base in bulk. This sort of integration can be complicated due to the different protocols followed by different identity systems.","title":"Spaghetti identity and federation silos"},{"location":"key-concepts/identity-anti-patterns-and-the-identity-bus/#how-this-impacts-enterprise-identity-management","text":"When working with both external and internal users and merging different systems together, you are faced with technicalities related to management of multiple heterogeneous user stores, different types of authentication protocols, legacy systems and many more. SAML, OpenID Connect, and WS-Federation all support identity federation and cross domain authentication. However, in a real world scenario, not all involved parties in a federation use case will support SAML and OpenID Connect. Most of the federation systems seen today are in silos. It can be a silo of SAML federation or a silo of OpenID Connect federation. While a system that uses SAML as it's protocol may be able to communicate with other SAML protocol-based systems, they may not be able to communicate with OpenID Connect. The diagram below illustrates how a silo of SAML federation and OpenID Connect federation interact within the respective silo and how it cannot interact with different silos. Also consider the scalability of a specific federation silo. Within the SAML federation silo, for example, there can be an increasing number of service providers and identity providers. Each service provider has to trust each identity provider and this leads to the Spaghetti Identity anti-pattern. The following diagram depicts the complexity of this.","title":"How this impacts enterprise identity management"},{"location":"key-concepts/identity-anti-patterns-and-the-identity-bus/#the-identity-bus","text":"Federation Silos and Spaghetti Identity are two anti-patterns directly addressed by the Identity Bus pattern in the WSO2 Identity Server. With Identity Bus, a given service provider is not coupled to a given identity provider and also not coupled to a given federation protocol. A user should be able to log into a service provider that accepts only SAML 2.0 tokens with an identity provider that issues only OpenID Connect tokens. The Identity Bus acts as a middle-man, or an Identity Broker, that mediates and transforms identity tokens between heterogeneous identity protocols. The following are some of the benefits of using the Identity Bus pattern. Introducing a new service provider is extremely easy. You only need to register the service provider in the Identity Bus and pick which identity providers it trusts. It is not necessary to add the service provider configuration to each and every identity provider. Similarly, removing an existing service provider is extremely easy. You only need to remove the service provider from the Identity Bus. It is not necessary to remove the service provider from each and every identity provider. Introducing a new identity provider is extremely easy. You only need to register the identity provider in the Identity Bus. It will be available for any service provider. Similarly, removing an existing identity provider is extremely easy. You only need to remove the identity provider from the Identity Bus. Enforcing new authentication protocols is extremely easy. Consider a scenario where you need to authenticate users with both the username and password and also Duo Security (SMS based authentication). To do this, you only need to add that capability to the Identity Bus and pick the required set of authentication protocols against a given service provider at the time of service provider registration. In the Identity Bus, each service provider can be configured based on how it authenticates users. Claim transformations. Your service provider may read user's email address from the \" http://sp1.org/claims/email \" attribute id - but the identity provider of the user may send it as \" http://idp1.org/claims/emai \" . Identity bus can transform the claims it receives from the identity provider to the format expected by the service provider. Role mapping. Your service provider needs to authorize users once they are logged in. What the user can do at the identity provider is different from what the same user can do at the service provider. User's roles from the identity provider define what he can do at the identity provider. Service provider's roles define the things a user can do at the service provider. Identity bus is capable of mapping identity provider's roles to the service provider's roles. For example a user may bring idp-admin role from his identity provider - in a SAML response - then the identity bus will find the mapped service provider role corresponding to this, say sp-admin, and will add that into the SAML response returning back to the service provider from the identity bus. Just-in-time provisioning. Since identity bus is at the middle of all identity transactions - it can provision all external user identities to an internal user store. Centralized monitoring and auditing. Introducing a new federation protocol needs minimal changes. If you have a service provider or an identity provider, which supports a proprietary federation protocol, then you only need to add that capability to the identity bus. No need to implement it at each and every identity provider or service provider.","title":"The identity bus"},{"location":"key-concepts/identity-provisioning-and-its-standards/","text":"Identity Provisioning and its Standards User and identity provisioning plays a key role in propagating users, user groups, and user identities across different systems and SaaS applications. Provisioning is the process of coordinating the creation of user accounts, e-mail authorizations in the form of rules and roles, and other tasks such as provisioning of resources associated with enabling new users. This is particularly useful when adding new users into your organization. WSO2 Identity Server can ensure that provisioning is made easy. A provisioning request can be sent to the Identity Server to add a new user and this user is provisioned to various applications that are configured with the Identity Server. This process is illustrated in the following diagram. Figure : User and identity provisioning using WSO2 Identity Server Inbound and outbound provisioning Inbound provisioning focuses on how to provision users, user groups, and user identities to the Identity Server. This can be done using the REST API available for SCIM. The following figure is an example of this process. Figure : Inbound provisioning Outbound provisioning involves provisioning users, user groups, and user identities to external systems or SaaS applications. Figure : Outbound provisioning Introducing SPML Service Provisioning Markup Language (SPML) is an XML-based framework developed by OASIS for exchanging user, resource, and service provisioning information between cooperating organizations. The Service Provisioning Markup Language is the open standard for the integration and interoperation of service provisioning requests. The goal of SPML is to allow organizations to securely and quickly set up user interfaces for Web services and applications, by letting enterprise platforms such as Web portals, application servers, and service centers generate provisioning requests within and across organizations. This can lead to automation of user or system access and entitlement rights to electronic services across diverse IT infrastructures, so that customers are not locked into proprietary solutions Introducing SCIM The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in cloud based applications and services, easier. User and identity provisioning is a key aspect of any identity management solution. In simple terms, it is to create, maintain, and delete user accounts and related identities in one or more systems or applications in response to business processes that are initiated either by humans directly or by automated tasks. Today the enterprise solutions adopt products and services from multiple cloud providers in order to accomplish various business requirements. Hence, it is no longer sufficient to maintain user identities only in a corporate LDAP. In most cases, SaaS providers also need dedicated user accounts created for the cloud service users, which raises the need of proper identity provisioning mechanisms to be in place. Currently, different cloud vendors expose non-standard provisioning APIs that make it a nightmare for the enterprises to develop and maintain proprietary connectors to integrate with multiple SaaS providers. For example, Google exposes the Google Provisioning API for provisioning user accounts in Google Apps Domain. When enterprise IT systems consist of distributed, heterogeneous components from multiple vendors, and from both in-house and cloud, it is key to have an open standard that all agree upon in order to achieve interoperability and simplicity while getting rid of multiple connectors to perform the same thing. SCIM is an emerging open standard that defines a comprehensive REST API, along with a platform neutral schema and a SAML binding to facilitate the user management operations across SaaS applications; placing specific emphasis on simplicity and interoperability. Brief history of identity provisioning Click here to read about the history of identity provisioning The following diagram illustrates the progressive development that has taken place in the history of identity provisioning. Figure : Provisioning evolution and history The OASIS Technical Committee for Service Provisioning was formed in 2001 to define an XML-based framework for exchanging user, resource, and service provisioning information. As a result, the SPML (Service Provisioning Mark Language) came up in 2003 and was based on three proprietary provisioning standards by that time. IBM and Microsoft played a major role in building the SPML 1.0. The following are the three proprietary provisioning standards. Information Technology Markup Language (ITML) Active Digital Profile (ADPr) eXtensible Resource Provisioning Management (XRPM) SPML 1.0 defined a Request/Response protocol as well as couple of bindings. Requests/Responses are all based on XML and each operation has it own schema. One of the bindings defined in SPML 1.0 is the SOAP binding. It specifies how to transfer SPML requests and responses wrapped in a SOAP message. All the SPML operations supported by the provisioning entity should be declared in the WSDL file itself. The other one is file binding. This binding refers to using SPML elements in a file, typically for the purposes of bulk processing provisioning data and provisioning schema documentation. In the closing stages of SPML 1.0, IBM and Microsoft felt strongly that support for complex XML objects needed to be done differently. The OASIS TC voted to postpone this effort until 2.0. As a result, IBM unofficially stated that they wouldn't be implementing 1.0 and would wait on the conclusion of the 2.0 process. IBM and Microsoft, who were part of the initial SPML specification, went ahead and started building their own standard for provisioning via SOAP based services. This is called WS-Provisioning. WS-Provisioning describes the APIs and schemas necessary to facilitate interoperability between provisioning systems in a consistent manner using Web services. It includes operations for adding, modifying, deleting, and querying provisioning data. It also specifies a notification interface for subscribing to provisioning events. Provisioning data is described using XML and other types of schema. This facilitates the translation of data between different provisioning systems. WS-Provisioning is part of the Service Oriented Architecture and has been submitted to the Organization for the Advancement of Structured Information Standards (OASIS) Provisioning Service Technical Committee. OASIS PSTC took both SPML 1.0 and WS-Provisioning specification as inputs and developed SPML 2.0 in 2006. SPML 1.0 has been called a slightly improved Directory Services Markup Language (DSML). SPML 2.0 defines an extensible protocol (through capabilities) with support for a DSML profile (SPMLv2 DSMLv2), as well as XML schema profiles. SPML 2.0 differentiates between the protocol and the data it carries. SPML 1.0 defined file bindings and SOAP bindings that assumed the SPML1.0 Schema for DSML. The SPMLv2 DSMLv2 Profile provides a degree of backward compatibility with SPML 1.0. The DSMLv2 profile supports a schema model similar to that of SPML 1.0. The DSMLv2 Profile may be more convenient for applications that mainly access targets that are LDAP or X500 directory services. The XSD Profile may be more convenient for applications that mainly access targets that are Web services. The SPML 2.0 protocol enables better interoperability between vendors, especially for the core capabilities (those found in 1.0). You can \u201cextend\u201d SPML 1.0 using ExtendedRequest, but there is no guidance about what those requests can be. SPML 2.0 defines a set of \u201cstandard capabilities\u201d that allow you to add support in well-defined ways. SPML definitely addressed the key objective of forming the OASIS PSTC in 2001. It solved the interoperability issues, however, it was too complex to implement. It was SOAP biased and was addressing too many concerns in provisioning than what actually was needed. It was around 2009 - 2010 that people started to talk about the death of SPML. In parallel to the criticisms against SPML - another standard known as SCIM (Simple Could Identity Management) started to emerge. This was around mid 2010 - and initiated by Salesforce, Ping Identity, Google and others. WSO2 joined the effort sometime in early 2011 and took part in all the interop events that have happened so far. SCIM is purely RESTful. The initial version supported both JSON and XML. SCIM introduced a REST API for provisioning and also a core schema (which also can be extended) for provisioning objects. SCIM 1.1 was finalized in 2012 - and then it was donated to the IETF . Once in IETF, it changed the definition of SCIM to System for Cross-domain Identity Management and it supports only JSON and now XML. As a result of the increasing pressure on OASIS PSTC, they started working on a REST binding for SPML, which is known as RESTPML , around 2011. This is still based on XML and not yet active so far.","title":"Identity Provisioning and its Standards"},{"location":"key-concepts/identity-provisioning-and-its-standards/#identity-provisioning-and-its-standards","text":"User and identity provisioning plays a key role in propagating users, user groups, and user identities across different systems and SaaS applications. Provisioning is the process of coordinating the creation of user accounts, e-mail authorizations in the form of rules and roles, and other tasks such as provisioning of resources associated with enabling new users. This is particularly useful when adding new users into your organization. WSO2 Identity Server can ensure that provisioning is made easy. A provisioning request can be sent to the Identity Server to add a new user and this user is provisioned to various applications that are configured with the Identity Server. This process is illustrated in the following diagram. Figure : User and identity provisioning using WSO2 Identity Server","title":"Identity Provisioning and its Standards"},{"location":"key-concepts/identity-provisioning-and-its-standards/#inbound-and-outbound-provisioning","text":"Inbound provisioning focuses on how to provision users, user groups, and user identities to the Identity Server. This can be done using the REST API available for SCIM. The following figure is an example of this process. Figure : Inbound provisioning Outbound provisioning involves provisioning users, user groups, and user identities to external systems or SaaS applications. Figure : Outbound provisioning","title":"Inbound and outbound provisioning"},{"location":"key-concepts/identity-provisioning-and-its-standards/#introducing-spml","text":"Service Provisioning Markup Language (SPML) is an XML-based framework developed by OASIS for exchanging user, resource, and service provisioning information between cooperating organizations. The Service Provisioning Markup Language is the open standard for the integration and interoperation of service provisioning requests. The goal of SPML is to allow organizations to securely and quickly set up user interfaces for Web services and applications, by letting enterprise platforms such as Web portals, application servers, and service centers generate provisioning requests within and across organizations. This can lead to automation of user or system access and entitlement rights to electronic services across diverse IT infrastructures, so that customers are not locked into proprietary solutions","title":"Introducing SPML"},{"location":"key-concepts/identity-provisioning-and-its-standards/#introducing-scim","text":"The System for Cross-domain Identity Management (SCIM) specification is designed to make managing user identities in cloud based applications and services, easier. User and identity provisioning is a key aspect of any identity management solution. In simple terms, it is to create, maintain, and delete user accounts and related identities in one or more systems or applications in response to business processes that are initiated either by humans directly or by automated tasks. Today the enterprise solutions adopt products and services from multiple cloud providers in order to accomplish various business requirements. Hence, it is no longer sufficient to maintain user identities only in a corporate LDAP. In most cases, SaaS providers also need dedicated user accounts created for the cloud service users, which raises the need of proper identity provisioning mechanisms to be in place. Currently, different cloud vendors expose non-standard provisioning APIs that make it a nightmare for the enterprises to develop and maintain proprietary connectors to integrate with multiple SaaS providers. For example, Google exposes the Google Provisioning API for provisioning user accounts in Google Apps Domain. When enterprise IT systems consist of distributed, heterogeneous components from multiple vendors, and from both in-house and cloud, it is key to have an open standard that all agree upon in order to achieve interoperability and simplicity while getting rid of multiple connectors to perform the same thing. SCIM is an emerging open standard that defines a comprehensive REST API, along with a platform neutral schema and a SAML binding to facilitate the user management operations across SaaS applications; placing specific emphasis on simplicity and interoperability.","title":"Introducing SCIM"},{"location":"key-concepts/identity-provisioning-and-its-standards/#brief-history-of-identity-provisioning","text":"Click here to read about the history of identity provisioning The following diagram illustrates the progressive development that has taken place in the history of identity provisioning. Figure : Provisioning evolution and history The OASIS Technical Committee for Service Provisioning was formed in 2001 to define an XML-based framework for exchanging user, resource, and service provisioning information. As a result, the SPML (Service Provisioning Mark Language) came up in 2003 and was based on three proprietary provisioning standards by that time. IBM and Microsoft played a major role in building the SPML 1.0. The following are the three proprietary provisioning standards. Information Technology Markup Language (ITML) Active Digital Profile (ADPr) eXtensible Resource Provisioning Management (XRPM) SPML 1.0 defined a Request/Response protocol as well as couple of bindings. Requests/Responses are all based on XML and each operation has it own schema. One of the bindings defined in SPML 1.0 is the SOAP binding. It specifies how to transfer SPML requests and responses wrapped in a SOAP message. All the SPML operations supported by the provisioning entity should be declared in the WSDL file itself. The other one is file binding. This binding refers to using SPML elements in a file, typically for the purposes of bulk processing provisioning data and provisioning schema documentation. In the closing stages of SPML 1.0, IBM and Microsoft felt strongly that support for complex XML objects needed to be done differently. The OASIS TC voted to postpone this effort until 2.0. As a result, IBM unofficially stated that they wouldn't be implementing 1.0 and would wait on the conclusion of the 2.0 process. IBM and Microsoft, who were part of the initial SPML specification, went ahead and started building their own standard for provisioning via SOAP based services. This is called WS-Provisioning. WS-Provisioning describes the APIs and schemas necessary to facilitate interoperability between provisioning systems in a consistent manner using Web services. It includes operations for adding, modifying, deleting, and querying provisioning data. It also specifies a notification interface for subscribing to provisioning events. Provisioning data is described using XML and other types of schema. This facilitates the translation of data between different provisioning systems. WS-Provisioning is part of the Service Oriented Architecture and has been submitted to the Organization for the Advancement of Structured Information Standards (OASIS) Provisioning Service Technical Committee. OASIS PSTC took both SPML 1.0 and WS-Provisioning specification as inputs and developed SPML 2.0 in 2006. SPML 1.0 has been called a slightly improved Directory Services Markup Language (DSML). SPML 2.0 defines an extensible protocol (through capabilities) with support for a DSML profile (SPMLv2 DSMLv2), as well as XML schema profiles. SPML 2.0 differentiates between the protocol and the data it carries. SPML 1.0 defined file bindings and SOAP bindings that assumed the SPML1.0 Schema for DSML. The SPMLv2 DSMLv2 Profile provides a degree of backward compatibility with SPML 1.0. The DSMLv2 profile supports a schema model similar to that of SPML 1.0. The DSMLv2 Profile may be more convenient for applications that mainly access targets that are LDAP or X500 directory services. The XSD Profile may be more convenient for applications that mainly access targets that are Web services. The SPML 2.0 protocol enables better interoperability between vendors, especially for the core capabilities (those found in 1.0). You can \u201cextend\u201d SPML 1.0 using ExtendedRequest, but there is no guidance about what those requests can be. SPML 2.0 defines a set of \u201cstandard capabilities\u201d that allow you to add support in well-defined ways. SPML definitely addressed the key objective of forming the OASIS PSTC in 2001. It solved the interoperability issues, however, it was too complex to implement. It was SOAP biased and was addressing too many concerns in provisioning than what actually was needed. It was around 2009 - 2010 that people started to talk about the death of SPML. In parallel to the criticisms against SPML - another standard known as SCIM (Simple Could Identity Management) started to emerge. This was around mid 2010 - and initiated by Salesforce, Ping Identity, Google and others. WSO2 joined the effort sometime in early 2011 and took part in all the interop events that have happened so far. SCIM is purely RESTful. The initial version supported both JSON and XML. SCIM introduced a REST API for provisioning and also a core schema (which also can be extended) for provisioning objects. SCIM 1.1 was finalized in 2012 - and then it was donated to the IETF . Once in IETF, it changed the definition of SCIM to System for Cross-domain Identity Management and it supports only JSON and now XML. As a result of the increasing pressure on OASIS PSTC, they started working on a REST binding for SPML, which is known as RESTPML , around 2011. This is still based on XML and not yet active so far.","title":"Brief history of identity provisioning"},{"location":"key-concepts/single-sign-on-and-identity-federation/","text":"Single Sign-On and Identity Federation Introducing single sign-on Single sign-on (SSO) is one of the key features of the WSO2 Identity Server that enables users to provide their credentials once and obtain access to multiple applications. The users are not prompted for their credentials when accessing each application until their session is terminated. Additionally, the user can access all these applications without having to log into each and every one of them individually. So, if users log into application A, for example, they would automatically have access to application B as well for the duration of that session without having to re-enter their credentials. The following are some of the advantages you can have with SSO: Users need only a single username/password pair to access multiple services. Thus they do not have the issue of remembering multiple username/password pairs. Users are authenticated only once at the identity provider and then they are automatically logged into all services within that \"trust-domain\". This process is more convenient to users since they do not have to provide their username/password at every service provider. Service providers do not have the overhead of managing user identities, which is more convenient for them. User identities are managed at a central point. This is more secure, less complex and easily manageable. How single sign-on works To understand how single sign-on works, it is useful to first examine how authentication works in a non SSO environment. The following diagram depicts this flow. Figure : Authentication in a non SSO environment In the above figure, the users access Application 1 first and then Application 2 using the same browser. The user is authenticated in Application 1 first and can access this application. When the users attempt to access Application 2 , they must enter their credentials again and get access to Application 2 separately. There is no way for Application 2 to access the cookie stored in the browser for Application 1 and authenticate the user by that means. The following diagram depicts how this story differs in a SSO environment. Figure : Authentication in a SSO environment In this second figure, the users access Application 1 first followed by Application 2 . Once again, the users use the same browser to access these applications. The users are redirected to the WSO2 Identity Server (or any authentication server that is configured for this task). If the users are already logged in to the Identity Server, the user is authenticated in Application 1 via an authentication token sent by the Identity Server to Application 1 . When Application 2 is accessed, the same thing happens and the users are redirected to the Identity Server and authenticated. This is how SSO works. SSO in reality Single sign-on is widely used in web technologies. Google is one of the best examples. Try this simple exercise. Visit www.google.com from your web browser. Click the SIGN IN button on the top right of the page. Once you sign in, you are redirected to https://accounts.google.com/ServiceLogin . There you are requested to enter your Username and Password. Enter your Google credentials there. Once you enter your Username and Password, you are directed back to www.google.com where you started. Next visit www.gmail.com , the Google mail server. Notice that you are automatically signed in and you directly access your Gmail Inbox. You did not have to enter your Username and Password at Gmail. In addition to that; now try www.youtube.com . You are automatically signed in. You do not have to enter your username and password at YouTube. Tip Tip : Notice the URL of the web browser. Each time you access an application, you see that you are being redirected to https://accounts.google.com/ServiceLogin and return immediately back to the website. Single Sign-On (SSO) allows you to sign in only once but provides access to multiple resources without having to re-enter your username and password. Supported protocols for SSO The following are the supported protocols for agent-based single sign-on. SAML 2.0 WS-Federation OpenID Connect WS-Trust The following sections in this topic expand on these protocols and provide details pertaining to them. SAML 2.0 SSO SAML stands for Security Assertion Markup Language, which is an XML-based data format for exchanging authentication and authorization data between an identity provider and a service provider. The single most important requirement that SAML addresses is web browser single sign-on (SSO). Three main roles are defined in SAML Specification. The Principal : This is typically the user who requires a service from a service provider entity. The Identity Provider : The SAML authority that provides the identity assertion to authenticate a principal. The Service Provider : The SAML consumer that provides the service for principals. The main use case scenario covered by SAML is the principal (the user) requesting access to a resource or service from the service provider. Then the service provider, using SAML, communicates with the identity provider to obtain identity assertion. The service provider makes the access control decision, depending on this assertion. SAML 2.0 is the latest version of SAML, which uses security tokens containing assertions to pass information about a user between an identity provider and a service provider. SAML 2.0 provides five main specifications: Core Bindings Profiles Metadata Conformances SAML 2.0 web browser-based SSO profile SAML 2.0 Web Browser based SSO profile is defined under the SAML 2.0 Profiles specification. In a web browser based SSO system, the flow can be started by the user either by attempting to access a service at the service provider or by directly accessing the identity provider itself. If the user accesses a service at a service provider: The service provider determines which identity provider to use (this is the case when there are multiple identity providers. SAML identity provider discovery profile may be used). The service provider generates a SAML message and then redirects the web browser to the identity provider along with the message. Identity provider authenticates the user. The identity provider generates a SAML message and then redirects the web browser back to the service provider. The service provider processes the SAML message and decides to grant or deny access to the user. If the user accesses the identity provider directly, then only the steps 3, 4 and 5 are in the flow. The following diagram depicts this flow. Figure : SAML 2.0 authentication flow The message MUST contain an element that uniquely identifies the service provider who created the message. Optionally, the message may contain elements such as Issuer, NameIDPolicy, etc. More information regarding the message can be found in SAML Core Specification . Click here for more information on assertion consumers, the authentication request and response SAML 2.0 SSO assertion consumers Service providers act as SAML assertion consumers. They have two basic functions: - Create messages and redirect users to the identity provider with the created message. Process messages from the identity provider and make decisions based on them. The following code is a sketch of a sample service provider servlet in a SAML 2.0 web browser-based SSO system. java public class Resource extends HttpServlet { private static SamlConsumer consumer = new SamlConsumer(); public void doGet(HttpServletRequest request, HttpServletResponse response) { requestMessage = consumer.buildRequestMessage(); response.sendRedirect(requestMessage); } public void doPost(HttpServletRequest request, HttpServletResponse response) { responseMessage = request.getParameter(\"SAMLResponse\").toString(); result = consumer.processResponseMessage(responseMessage); } } When a web user attempts to access the above servlet, its doGet() method is called. Inside the doGet() method, it generates an message and then redirects the user to the identity provider. After authentication is completed by the identity provider, it does a POST callback to the above servlet with a message. Then the doPost() method of the servlet gets called and inside the doPost() method, it retrieves the message from the request and then the message is passed to the SamlConsumer instance for processing. ** AuthnRequest message** To create an AuthnRequest message using the OpenSAML library, do the following. Add the OpenSAML library to the build path of the project. You can download the OpenSAML .jar file from here . A sample AuthnRequest message can be found here . According to SAML 2.0 specifications, the message must contain an element. Create the Issuer element first. java String issuerId = \"saml2.sso.demo\"; IssuerBuilder issuerBuilder = new IssuerBuilder(); Issuer issuer = issuerBuilder.buildObject(\"urn:oasis:names:tc:SAML: 2.0:assertion\", \"Issuer\", \"samlp\"); issuer.setValue(issuerId); Create the AuthnRequest next. java // the issuerUrl is the url of the service provider who generates the message String issuerUrl = \"http://localhost:8080/saml2.sso.demo/consumer\"; DateTime issueInstant = new DateTime(); AuthnRequestBuilder authnRequestBuilder = new AuthnRequestBuilder(); AuthnRequest authnRequest = authnRequestBuilder.buildObject(\"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\", \"samlp\"); authnRequest.setForceAuthn(false); authnRequest.setIsPassive(false); authnRequest.setIssueInstant(issueInstant); authnRequest.setProtocolBinding(\"urn:oasis:names:tc:SAML: 2.0:bindings:HTTP-POST\"); authnRequest.setAssertionConsumerServiceURL(issuerUrl); authnRequest.setIssuer(issuer); authnRequest.setID(aRandomId); authnRequest.setVersion(SAMLVersion.VERSION_20); The message may contain many other elements like \",\" etc. those elements can be created and added to the message in the same way. Next encode the message. ``` java Marshaller marshaller = Configuration.getMarshallerFactory().getMarshaller(authnRequest); Element authDOM = marshaller.marshall(authnRequest); StringWriter rspWrt = new StringWriter(); XMLHelper.writeNode(authDOM, rspWrt); String requestMessage = rspWrt.toString(); Deflater deflater = new Deflater(Deflater.DEFLATED, true); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, deflater); deflaterOutputStream.write(requestMessage.getBytes()); deflaterOutputStream.close(); /* Encoding the compressed message */ String encodedRequestMessage = Base64.encodeBytes(byteArrayOutputStream.toByteArray(), Base64.DONT_BREAK_LINES); String encodedAuthnRequest = URLEncoder.encode(encodedRequestMessage,\"UTF-8\").trim(); ``` Construct the redirection URL. java redirectionUrl = identitypProviderUrl+ \"?SAMLRequest=\" + encodedRequestMessage; Redirect the user to the identity provider. java response.sendRedirect(redirectionUrl); ** Response message** The Identity provider must use HTTP POST or artifact binding to transfer the SAMLResponse message to the service provider. To read the Response message issued by the WSO2 Identity Server, do the following: A sample Response message can be found here . The response message must be fetched from the request. java responseMessage = request.getParameter(\"SAMLResponse\").toString(); The fetched responseMessage is unmarshaled and the SAML message is retrieved. java DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); documentBuilderFactory.setNamespaceAware(true); DocumentBuilder docBuilder = documentBuilderFactory.newDocumentBuilder(); byte[] base64DecodedResponse = Base64.decode(responseMessage); ByteArrayInputStream is = new ByteArrayInputStream(base64DecodedResponse); Document document = docBuilder.parse(is); Element element = document.getDocumentElement(); UnmarshallerFactory unmarshallerFactory = Configuration.getUnmarshallerFactory(); Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element); Response response = (Response) unmarshaller.unmarshall(element); The retrieved SAML 2.0 response message can be easily processed. For example, let's take the username or the subject's NameID . java String subject = response.getAssertions().get(0).getSubject() .getNameID().getValue(); Alternatively, if the response is signed by the identity provider, you can retrieve the certificate. java String certificate = response.getSignature().getKeyInfo().getX509Datas().get(0).getX509Certificates().get(0).getValue(); Identity provider initiated SSO To initiate IdP Initiated SSO you need to perform a HTTP GET/POST to the following URL (assume the registered service provider issuer ID is foo.com ). The SAML protocol message can be encoded using Base64 encoding. https://localhost:9443/samlsso?spEntityID=foo.com This request will authenticate and redirect the user to the registered Assertion Consumer URL. Optionally, you can send in a RelayState parameter as follows: https://localhost:9443/samlsso?spEntityID=foo.com RelayState=http://localhost:8080/foo.com/my-home.jsp The RelayState parameter must be URL encoded. This request will authenticate and redirect the user to the URL in the RelayState parameter itself. Either you could have service provider initiated SSO only, or service provider initiated SSO and identity provider initiated SSO. You cannot have only identity provider initiated SSO. By design, service provider initiated SSO is more restrictive and secure. If a service provider is allowed to do identity provider initiated SSO, it would automatically imply that this service provider is allowed to do service provider initiated SSO as well. Recommended reading See SAML 2.0 specification documentation for more information. WS-Federation WS-Federation (Web Services Federation) describes the management and brokering of trust relationships and security token exchange across Web services and organizational boundaries. WS-Federation is a part of the larger WS-Security framework. For example, WS-Federation builds on the Security Token Service (STS) by providing mechanisms that facilitate interactions. In the WS-Federation Model, an Identity Provider is a Security Token Service (STS). Recommended reading See WS-Federation specification documentation for more information. OpenID Connect OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. OpenID Connect allows clients of all types, including Web-based, mobile, and JavaScript clients, to request and receive information about authenticated sessions and end-users. The specification suite is extensible, allowing participants to use optional features such as encryption of identity data, discovery of OpenID Providers, and session management, when it makes sense for them. Recommended reading See OpenID Connect specification documentation for more information. WS-Trust The \"Security Token Service\" (STS) component of WSO2 Identity Server enables you to configure the generic STS to issue claim-based security tokens. A claim-based security token is a common way for applications to acquire and authenticate the identity information they need about users inside their organization, in other organizations, and on the Internet. This Security Token Service is capable of issuing SAML 1.1 and SAML 2.0 tokens as recommended in WS-Trust and SAML Web Service Token Profile specifications. The WSDL of this service can be accessed by clicking this URL: https://(hostname):(port)/services/wso2carbon-sts?wsdl . For instance, with the default configuration, the URL is https://localhost:9443/services/wso2carbon-sts?wsdl . Both SAML 1.1 and SAML 2.0 token types are supported by default. The issued token type is decided based on the type of token defined in the RST (Request Security Token). Currently, the Bearer Subject Confirmation and Holder-Of-Key subject confirmation methods are both supported. With Holder-Of-Key, both Symmetric and Asymmetric key types are supported. You can obtain tokens containing claims that hold certain information about the subject. These claims can be extracted from the profiles or through custom claim callbacks which can be registered to the Carbon runtime. Related Topics See WS-Trust specification documentation for more information. See Configuring WS-Trust Security Token Service to configure WS-Trust in WSO2 Identity Server. Identity federation and a comparison with SSO Identity and access management requirements are rapidly evolving over the years. Organizations cannot survive with authentication and authorization mechanisms that only span a single boundary of trust. Hence, these organizations often provide and consume services across trust boundaries, which may include partners, subsidiaries, customers or suppliers and may span across multiple buildings, cities, states, countries and even continents. Identity federation and Single Sign On (SSO) come into the picture to provide and consume these services across trust boundaries. Identity federation and SSO have similarities as well as key differences. Identity federation enables users to access multiple applications using the same access credentials. This makes access easy, as users do not have to remember a different set of credentials for every application they use. However, the users have to provide their credentials to each one of the applications separately although the credentials used are the same. On the other hand, SSO enables users to provide their credentials once and obtain access to multiple applications. In SSO, the users are not prompted for their credentials when accessing each application until their session is terminated.","title":"Single Sign-On and Identity Federation"},{"location":"key-concepts/single-sign-on-and-identity-federation/#single-sign-on-and-identity-federation","text":"","title":"Single Sign-On and Identity Federation"},{"location":"key-concepts/single-sign-on-and-identity-federation/#introducing-single-sign-on","text":"Single sign-on (SSO) is one of the key features of the WSO2 Identity Server that enables users to provide their credentials once and obtain access to multiple applications. The users are not prompted for their credentials when accessing each application until their session is terminated. Additionally, the user can access all these applications without having to log into each and every one of them individually. So, if users log into application A, for example, they would automatically have access to application B as well for the duration of that session without having to re-enter their credentials. The following are some of the advantages you can have with SSO: Users need only a single username/password pair to access multiple services. Thus they do not have the issue of remembering multiple username/password pairs. Users are authenticated only once at the identity provider and then they are automatically logged into all services within that \"trust-domain\". This process is more convenient to users since they do not have to provide their username/password at every service provider. Service providers do not have the overhead of managing user identities, which is more convenient for them. User identities are managed at a central point. This is more secure, less complex and easily manageable.","title":"Introducing single sign-on"},{"location":"key-concepts/single-sign-on-and-identity-federation/#how-single-sign-on-works","text":"To understand how single sign-on works, it is useful to first examine how authentication works in a non SSO environment. The following diagram depicts this flow. Figure : Authentication in a non SSO environment In the above figure, the users access Application 1 first and then Application 2 using the same browser. The user is authenticated in Application 1 first and can access this application. When the users attempt to access Application 2 , they must enter their credentials again and get access to Application 2 separately. There is no way for Application 2 to access the cookie stored in the browser for Application 1 and authenticate the user by that means. The following diagram depicts how this story differs in a SSO environment. Figure : Authentication in a SSO environment In this second figure, the users access Application 1 first followed by Application 2 . Once again, the users use the same browser to access these applications. The users are redirected to the WSO2 Identity Server (or any authentication server that is configured for this task). If the users are already logged in to the Identity Server, the user is authenticated in Application 1 via an authentication token sent by the Identity Server to Application 1 . When Application 2 is accessed, the same thing happens and the users are redirected to the Identity Server and authenticated. This is how SSO works.","title":"How single sign-on works"},{"location":"key-concepts/single-sign-on-and-identity-federation/#sso-in-reality","text":"Single sign-on is widely used in web technologies. Google is one of the best examples. Try this simple exercise. Visit www.google.com from your web browser. Click the SIGN IN button on the top right of the page. Once you sign in, you are redirected to https://accounts.google.com/ServiceLogin . There you are requested to enter your Username and Password. Enter your Google credentials there. Once you enter your Username and Password, you are directed back to www.google.com where you started. Next visit www.gmail.com , the Google mail server. Notice that you are automatically signed in and you directly access your Gmail Inbox. You did not have to enter your Username and Password at Gmail. In addition to that; now try www.youtube.com . You are automatically signed in. You do not have to enter your username and password at YouTube. Tip Tip : Notice the URL of the web browser. Each time you access an application, you see that you are being redirected to https://accounts.google.com/ServiceLogin and return immediately back to the website. Single Sign-On (SSO) allows you to sign in only once but provides access to multiple resources without having to re-enter your username and password.","title":"SSO in reality"},{"location":"key-concepts/single-sign-on-and-identity-federation/#supported-protocols-for-sso","text":"The following are the supported protocols for agent-based single sign-on. SAML 2.0 WS-Federation OpenID Connect WS-Trust The following sections in this topic expand on these protocols and provide details pertaining to them.","title":"Supported protocols for SSO"},{"location":"key-concepts/single-sign-on-and-identity-federation/#saml-20-sso","text":"SAML stands for Security Assertion Markup Language, which is an XML-based data format for exchanging authentication and authorization data between an identity provider and a service provider. The single most important requirement that SAML addresses is web browser single sign-on (SSO). Three main roles are defined in SAML Specification. The Principal : This is typically the user who requires a service from a service provider entity. The Identity Provider : The SAML authority that provides the identity assertion to authenticate a principal. The Service Provider : The SAML consumer that provides the service for principals. The main use case scenario covered by SAML is the principal (the user) requesting access to a resource or service from the service provider. Then the service provider, using SAML, communicates with the identity provider to obtain identity assertion. The service provider makes the access control decision, depending on this assertion. SAML 2.0 is the latest version of SAML, which uses security tokens containing assertions to pass information about a user between an identity provider and a service provider. SAML 2.0 provides five main specifications: Core Bindings Profiles Metadata Conformances","title":"SAML 2.0 SSO"},{"location":"key-concepts/single-sign-on-and-identity-federation/#saml-20-web-browser-based-sso-profile","text":"SAML 2.0 Web Browser based SSO profile is defined under the SAML 2.0 Profiles specification. In a web browser based SSO system, the flow can be started by the user either by attempting to access a service at the service provider or by directly accessing the identity provider itself. If the user accesses a service at a service provider: The service provider determines which identity provider to use (this is the case when there are multiple identity providers. SAML identity provider discovery profile may be used). The service provider generates a SAML message and then redirects the web browser to the identity provider along with the message. Identity provider authenticates the user. The identity provider generates a SAML message and then redirects the web browser back to the service provider. The service provider processes the SAML message and decides to grant or deny access to the user. If the user accesses the identity provider directly, then only the steps 3, 4 and 5 are in the flow. The following diagram depicts this flow. Figure : SAML 2.0 authentication flow The message MUST contain an element that uniquely identifies the service provider who created the message. Optionally, the message may contain elements such as Issuer, NameIDPolicy, etc. More information regarding the message can be found in SAML Core Specification . Click here for more information on assertion consumers, the authentication request and response SAML 2.0 SSO assertion consumers Service providers act as SAML assertion consumers. They have two basic functions: - Create messages and redirect users to the identity provider with the created message. Process messages from the identity provider and make decisions based on them. The following code is a sketch of a sample service provider servlet in a SAML 2.0 web browser-based SSO system. java public class Resource extends HttpServlet { private static SamlConsumer consumer = new SamlConsumer(); public void doGet(HttpServletRequest request, HttpServletResponse response) { requestMessage = consumer.buildRequestMessage(); response.sendRedirect(requestMessage); } public void doPost(HttpServletRequest request, HttpServletResponse response) { responseMessage = request.getParameter(\"SAMLResponse\").toString(); result = consumer.processResponseMessage(responseMessage); } } When a web user attempts to access the above servlet, its doGet() method is called. Inside the doGet() method, it generates an message and then redirects the user to the identity provider. After authentication is completed by the identity provider, it does a POST callback to the above servlet with a message. Then the doPost() method of the servlet gets called and inside the doPost() method, it retrieves the message from the request and then the message is passed to the SamlConsumer instance for processing. ** AuthnRequest message** To create an AuthnRequest message using the OpenSAML library, do the following. Add the OpenSAML library to the build path of the project. You can download the OpenSAML .jar file from here . A sample AuthnRequest message can be found here . According to SAML 2.0 specifications, the message must contain an element. Create the Issuer element first. java String issuerId = \"saml2.sso.demo\"; IssuerBuilder issuerBuilder = new IssuerBuilder(); Issuer issuer = issuerBuilder.buildObject(\"urn:oasis:names:tc:SAML: 2.0:assertion\", \"Issuer\", \"samlp\"); issuer.setValue(issuerId); Create the AuthnRequest next. java // the issuerUrl is the url of the service provider who generates the message String issuerUrl = \"http://localhost:8080/saml2.sso.demo/consumer\"; DateTime issueInstant = new DateTime(); AuthnRequestBuilder authnRequestBuilder = new AuthnRequestBuilder(); AuthnRequest authnRequest = authnRequestBuilder.buildObject(\"urn:oasis:names:tc:SAML:2.0:protocol\", \"AuthnRequest\", \"samlp\"); authnRequest.setForceAuthn(false); authnRequest.setIsPassive(false); authnRequest.setIssueInstant(issueInstant); authnRequest.setProtocolBinding(\"urn:oasis:names:tc:SAML: 2.0:bindings:HTTP-POST\"); authnRequest.setAssertionConsumerServiceURL(issuerUrl); authnRequest.setIssuer(issuer); authnRequest.setID(aRandomId); authnRequest.setVersion(SAMLVersion.VERSION_20); The message may contain many other elements like \",\" etc. those elements can be created and added to the message in the same way. Next encode the message. ``` java Marshaller marshaller = Configuration.getMarshallerFactory().getMarshaller(authnRequest); Element authDOM = marshaller.marshall(authnRequest); StringWriter rspWrt = new StringWriter(); XMLHelper.writeNode(authDOM, rspWrt); String requestMessage = rspWrt.toString(); Deflater deflater = new Deflater(Deflater.DEFLATED, true); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, deflater); deflaterOutputStream.write(requestMessage.getBytes()); deflaterOutputStream.close(); /* Encoding the compressed message */ String encodedRequestMessage = Base64.encodeBytes(byteArrayOutputStream.toByteArray(), Base64.DONT_BREAK_LINES); String encodedAuthnRequest = URLEncoder.encode(encodedRequestMessage,\"UTF-8\").trim(); ``` Construct the redirection URL. java redirectionUrl = identitypProviderUrl+ \"?SAMLRequest=\" + encodedRequestMessage; Redirect the user to the identity provider. java response.sendRedirect(redirectionUrl); ** Response message** The Identity provider must use HTTP POST or artifact binding to transfer the SAMLResponse message to the service provider. To read the Response message issued by the WSO2 Identity Server, do the following: A sample Response message can be found here . The response message must be fetched from the request. java responseMessage = request.getParameter(\"SAMLResponse\").toString(); The fetched responseMessage is unmarshaled and the SAML message is retrieved. java DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); documentBuilderFactory.setNamespaceAware(true); DocumentBuilder docBuilder = documentBuilderFactory.newDocumentBuilder(); byte[] base64DecodedResponse = Base64.decode(responseMessage); ByteArrayInputStream is = new ByteArrayInputStream(base64DecodedResponse); Document document = docBuilder.parse(is); Element element = document.getDocumentElement(); UnmarshallerFactory unmarshallerFactory = Configuration.getUnmarshallerFactory(); Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element); Response response = (Response) unmarshaller.unmarshall(element); The retrieved SAML 2.0 response message can be easily processed. For example, let's take the username or the subject's NameID . java String subject = response.getAssertions().get(0).getSubject() .getNameID().getValue(); Alternatively, if the response is signed by the identity provider, you can retrieve the certificate. java String certificate = response.getSignature().getKeyInfo().getX509Datas().get(0).getX509Certificates().get(0).getValue();","title":"SAML 2.0 web browser-based SSO profile"},{"location":"key-concepts/single-sign-on-and-identity-federation/#identity-provider-initiated-sso","text":"To initiate IdP Initiated SSO you need to perform a HTTP GET/POST to the following URL (assume the registered service provider issuer ID is foo.com ). The SAML protocol message can be encoded using Base64 encoding. https://localhost:9443/samlsso?spEntityID=foo.com This request will authenticate and redirect the user to the registered Assertion Consumer URL. Optionally, you can send in a RelayState parameter as follows: https://localhost:9443/samlsso?spEntityID=foo.com RelayState=http://localhost:8080/foo.com/my-home.jsp The RelayState parameter must be URL encoded. This request will authenticate and redirect the user to the URL in the RelayState parameter itself. Either you could have service provider initiated SSO only, or service provider initiated SSO and identity provider initiated SSO. You cannot have only identity provider initiated SSO. By design, service provider initiated SSO is more restrictive and secure. If a service provider is allowed to do identity provider initiated SSO, it would automatically imply that this service provider is allowed to do service provider initiated SSO as well. Recommended reading See SAML 2.0 specification documentation for more information.","title":"Identity provider initiated SSO"},{"location":"key-concepts/single-sign-on-and-identity-federation/#ws-federation","text":"WS-Federation (Web Services Federation) describes the management and brokering of trust relationships and security token exchange across Web services and organizational boundaries. WS-Federation is a part of the larger WS-Security framework. For example, WS-Federation builds on the Security Token Service (STS) by providing mechanisms that facilitate interactions. In the WS-Federation Model, an Identity Provider is a Security Token Service (STS). Recommended reading See WS-Federation specification documentation for more information.","title":"WS-Federation"},{"location":"key-concepts/single-sign-on-and-identity-federation/#openid-connect","text":"OpenID Connect is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner. OpenID Connect allows clients of all types, including Web-based, mobile, and JavaScript clients, to request and receive information about authenticated sessions and end-users. The specification suite is extensible, allowing participants to use optional features such as encryption of identity data, discovery of OpenID Providers, and session management, when it makes sense for them. Recommended reading See OpenID Connect specification documentation for more information.","title":"OpenID Connect"},{"location":"key-concepts/single-sign-on-and-identity-federation/#ws-trust","text":"The \"Security Token Service\" (STS) component of WSO2 Identity Server enables you to configure the generic STS to issue claim-based security tokens. A claim-based security token is a common way for applications to acquire and authenticate the identity information they need about users inside their organization, in other organizations, and on the Internet. This Security Token Service is capable of issuing SAML 1.1 and SAML 2.0 tokens as recommended in WS-Trust and SAML Web Service Token Profile specifications. The WSDL of this service can be accessed by clicking this URL: https://(hostname):(port)/services/wso2carbon-sts?wsdl . For instance, with the default configuration, the URL is https://localhost:9443/services/wso2carbon-sts?wsdl . Both SAML 1.1 and SAML 2.0 token types are supported by default. The issued token type is decided based on the type of token defined in the RST (Request Security Token). Currently, the Bearer Subject Confirmation and Holder-Of-Key subject confirmation methods are both supported. With Holder-Of-Key, both Symmetric and Asymmetric key types are supported. You can obtain tokens containing claims that hold certain information about the subject. These claims can be extracted from the profiles or through custom claim callbacks which can be registered to the Carbon runtime. Related Topics See WS-Trust specification documentation for more information. See Configuring WS-Trust Security Token Service to configure WS-Trust in WSO2 Identity Server.","title":"WS-Trust"},{"location":"key-concepts/single-sign-on-and-identity-federation/#identity-federation-and-a-comparison-with-sso","text":"Identity and access management requirements are rapidly evolving over the years. Organizations cannot survive with authentication and authorization mechanisms that only span a single boundary of trust. Hence, these organizations often provide and consume services across trust boundaries, which may include partners, subsidiaries, customers or suppliers and may span across multiple buildings, cities, states, countries and even continents. Identity federation and Single Sign On (SSO) come into the picture to provide and consume these services across trust boundaries. Identity federation and SSO have similarities as well as key differences. Identity federation enables users to access multiple applications using the same access credentials. This makes access easy, as users do not have to remember a different set of credentials for every application they use. However, the users have to provide their credentials to each one of the applications separately although the credentials used are the same. On the other hand, SSO enables users to provide their credentials once and obtain access to multiple applications. In SSO, the users are not prompted for their credentials when accessing each application until their session is terminated.","title":"Identity federation and a comparison with SSO"},{"location":"references/adaptive-authentication-js-api-reference/","text":"Adaptive Authentication JS API Reference With adaptive authentication, it is possible to configure dynamic sequences based on runtime parameters such as the user\u2019s IP address, user role, etc. WSO2 Identity Server allows you to define a dynamic authentication sequence using authentication scripts written in JavaScript. For more information on adaptive authentication, see Adaptive Authentication The following sections present the core API reference for the JavaScript-based conditional authentication functions and fields. Tip As the authentication script is designed as a loosely typed, functional language similar to JavaScript, common knowledge on JavaScript may help you to compose effective authentication scripts. Core functions onLoginRequest(context) This function is called when the initial authentication request is received by the framework. It includes the following parameters. Parameter Description context The authentication context, which contains the context information about the request. executeStep(stepId, options, eventCallbacks) This function is called to execute an authentication step. Authentication steps need to be configured prior to using this function. This method accepts an object as a parameter and should include the following. Parameter Description stepId The step number (mandatory) options An optional map that can configure step execution. Authentication option filtering is supported. For more information, see authentication step filtering . eventCallbacks The object that contains the callback functions that are to be called based on the result of the step execution. Supported results are \u201c onSuccess \u201d and \u201c onFail \u201d, which can have their own optional callbacks as anonymous functions (optional). The API can be called in either of the following ways: With only the stepId . Example: java executeStep(1) With only the stepId and eventCallbacks . Example: java executeStep(1, { onSuccess: function(context) { //Do something on success } }); With the stepId , options , and an empty eventCallbacks array. Example: java executeStep(1,{ authenticationOptions:[{ authenticator: 'totp' }]}, }); Note The API cannot be called with only the stepId and options . Authentication step filtering Filters out some of the authentication options of a step based on some condition. This can be achieved by specifying an array named \u2018 authenticationOptions \u2019 to the options map. Each array item will require an ' idp' for federated IdPs or an ' authenticator' for local authenticators. Example code executeStep(1,{ authenticationOptions:[{authenticator:'basic'},{idp:'google'}] } ,{ onSuccess: function (context) { // Do something on success }; Utility functions The implementation of utility functions can be found in the WSO2 extensions code repository . hasRole(user, role) This function returns true if the specified \u2018 user \u2019 belongs to the specified \u2018 role ', and returns false if the user does not. It includes the following parameters. Parameter Description user A user object representing the user details. role A string representing the role name. Example code var user = context.steps[1].subject; var isAdmin = hasRole(user, 'admin'); Log.info('--------------- Has Admin ' + isAdmin); if (isAdmin) { executeStep(2); } assignUserRoles(user, assigningRoles) This function assigns each of the roles specified in the \u2018 assigningRoles \u2019 parameter to the specified \u2018 user \u2019 object. It returns true if all the roles are successfully assigned and returns false if not. It includes the following parameters. Parameter Description user An object representing the user details. assigningRoles A list of strings containing roles that are to be assigned where each string is a role name. executeStep(1, { onSuccess: function (context) { // Extracting authenticated subject from the first step. let user = context.currentKnownSubject; assignUserRoles(user, ['exampleRole1', 'exampleRole2']); } }); removeUserRoles(user, removingRoles) This function r emoves each of the roles specified in the \u2018 removingRoles \u2019 parameter to the given \u2018 user \u2019 object. It returns true if all the roles are successfully removed and returns false if not. It includes the following parameters. Parameter Description user An object representing the user details. removingRoles A list of strings that containing roles that are to be removed where each string is a role name. executeStep(1, { onSuccess: function (context) { // Extracting authenticated subject from the first step. let user = context.currentKnownSubject; removeUserRoles(user, ['exampleRole1', 'exampleRole2']); } }); sendEmail(user, templateId, placeholderParameters) This function sends an email to the specified user. It includes the following parameters. Parameter Description user An object representing the user details. templateId Identifier of the email template. The email template specifies the body of the email that is sent out. placeholderParameters Used to replace any placeholders in the template. Example code var user = context.steps[1].subject; var firstName = user.localClaims['http://wso2.org/claims/givenname']; sendEmail(user, 'myTemplate', {'firstName':firstName}); sendError(url,parameters) This function redirects the user to an error page. It includes the following parameters. Parameter Description url The URL of the error page that the user is redirected to. If the value is null, the user is redirected by default to the ' retry.do' error page. Note that any relative URL is assumed as the relative to host\u2019s root. parameters Key value map passed as parameters. These are converted to query parameters in the URL. Example code var user = context.steps[1].subject; var isAdmin = hasRole(user, 'admin'); if (!isAdmin) { sendError('http://www.example.com/error',{'errorcode':'000403','errorMsg':'You are not allowed to login to this app.'}); } Tip Tip : When passing error messages to the error page, it is recommended to use the i18n key so that it can be internationalized easily at the page. setCookie(response, name, value, properties) This functions sets a new cookie. It includes the following parameters. Parameter Description name Name of the cookie. value Value of the cookie. properties A map that may contain optional attributes of the cookie with two other custom attributes \u2018 encrypt \u2019 and \u2018 sign \u2019. The default value of ' sign ' is false. If it is set to true, the value will be signed. The default value of ' encrypt ' is false. If it is set to true, value will be encrypted. Tip The size of the value has to be less than the RSA key pair length if ' encrypt ' is enabled (set to true). setCookie(context.response, name , test , { max-age : 4000, path : / , domain : localhost , httpOnly : true, secure : true, version : 1, comment : some comments , encrypt : true, sign : true}) getCookieValue(request, name, properties) This function gets the plain-text cookie value for the cookie \u2018 name \u2019 if present. It includes the following parameters. Parameter Description name Name of the cookie. value Value of the cookie. properties A map that may contain optional attributes of the cookie \u2018 de crypt validateSignature The default value of ' decrypt ' is false. If it is set to true, the value will be decrypted. The default value of ' validateSignature ' is false. If it is set to true, the signature will be validated before returning a response. getCookieValue(context.request, name , { decrypt : true, validateSignature : true }) callAnalytics( metadata, payloadData, eventHandlers ) This function calls the analytics engine (i.e., WSO2 Stream Processor) to get a decision. It includes the following parameters. Parameter Description metadata A JSON object that contain the following attributes: Application: Siddhi application name (mandatory) InputStream: Input stream name (mandatory) payloadData The data that needs to be sent to the analytics engine. eventHandlers The callback event handlers. publishToAnalytics( metadata, payloadData ) This function publishes data to the analytics engine (WSO2 Stream Processor). It includes the following parameters. Parameter Description metadata A JSON object that contain the following attributes: Application: Siddhi application name (mandatory) InputStream: Input stream name (mandatory) payloadData The data that needs to be sent to the analytics engine. prompt(templateId, data, eventHandlers) This function prompts for user input. It includes the following parameters. Parameter Description templateId Identifier of the template that needs to be prompted. data The data to send to the prompt. eventHandlers The callback event handlers. function onLoginRequest(context) { executeStep(1, { onSuccess: function (context) { var username = context.steps[1].subject.username; prompt( genericForm , { username :username, inputs :[{ id :fname, label : First Name },{ id :lname, label : Last Name }]}, { onSuccess : function(context) { var fname = context.request.params.fname[0]; var lname = context.request.params.lname[0]; Log.info(fname); Log.info(lname); } }); } }); } Object Reference context Object Contains the authentication context information. The information can be accessed as follows. context.steps[ n ] : Access the authentication step information, where n is the step number (1-based). See step Object for more information. Note Note : The step number is the one configured at the step configuration, not the actual order in which they get executed. context.request : Access the HTTP authentication request information. See request Object for more information. context.response : Access the HTTP response which will be sent back to the client. See response Object for more information. context.serviceProviderName : Get the application name. step Object Contains the authentication step information. May be null or invalid step number. step.subject : Contains the authenticated user\u2019s information from this step. May be null if the step is not yet executed. See user Object for more information. step.idp : Gives the Idp name which was used to authenticate this user. user Object user.username : The user\u2019s username. user.tenantDomain : The user\u2019s tenant domain (only for local users; federated users will have this as carbon.super ). user.userStoreDomain : The user\u2019s user store domain (only for local users). user.roles : List of user\u2019s roles. user.localClaims[\u201c local_claim_url \u201d] : (Read/Write) User\u2019s attribute (claim) value for the given \u201clocal_claim_url\u201d. If the user is a federated user, this will be the value of the mapped remote claim from the IdP. user.remoteClaims[\u201c remote_claim_url\u201d] : (Read/Write) User\u2019s attribute (claim) as returned by IdP for the given \u201cremote_claim_url\u201d. Applicable only for federated users. request Object request.headers[\u201c header_name \u201d] : Request\u2019s header value for the given header name by header_name request.params[\u201c param_name \u201d] : Request\u2019s parameter value for the given parameter name by parameter_name request.cookies[\u201c cookie_name\u201d] : Request\u2019s cookie value for the given cookie name by cookie_name request.ip : The client IP address of the user who initiated the request. If there are any load balancers (eg. Nginx) with connection termination, the ip is retrieved from the headers set by the load balancer. response Object request.headers[\u201c header_name \u201d] : (Write) Response header value for the given header name by header_name","title":"Adaptive Authentication JS API Reference"},{"location":"references/adaptive-authentication-js-api-reference/#adaptive-authentication-js-api-reference","text":"With adaptive authentication, it is possible to configure dynamic sequences based on runtime parameters such as the user\u2019s IP address, user role, etc. WSO2 Identity Server allows you to define a dynamic authentication sequence using authentication scripts written in JavaScript. For more information on adaptive authentication, see Adaptive Authentication The following sections present the core API reference for the JavaScript-based conditional authentication functions and fields. Tip As the authentication script is designed as a loosely typed, functional language similar to JavaScript, common knowledge on JavaScript may help you to compose effective authentication scripts.","title":"Adaptive Authentication JS API Reference"},{"location":"references/adaptive-authentication-js-api-reference/#core-functions","text":"","title":"Core functions"},{"location":"references/adaptive-authentication-js-api-reference/#onloginrequestcontext","text":"This function is called when the initial authentication request is received by the framework. It includes the following parameters. Parameter Description context The authentication context, which contains the context information about the request.","title":"onLoginRequest(context)"},{"location":"references/adaptive-authentication-js-api-reference/#executestepstepid-options-eventcallbacks","text":"This function is called to execute an authentication step. Authentication steps need to be configured prior to using this function. This method accepts an object as a parameter and should include the following. Parameter Description stepId The step number (mandatory) options An optional map that can configure step execution. Authentication option filtering is supported. For more information, see authentication step filtering . eventCallbacks The object that contains the callback functions that are to be called based on the result of the step execution. Supported results are \u201c onSuccess \u201d and \u201c onFail \u201d, which can have their own optional callbacks as anonymous functions (optional). The API can be called in either of the following ways: With only the stepId . Example: java executeStep(1) With only the stepId and eventCallbacks . Example: java executeStep(1, { onSuccess: function(context) { //Do something on success } }); With the stepId , options , and an empty eventCallbacks array. Example: java executeStep(1,{ authenticationOptions:[{ authenticator: 'totp' }]}, }); Note The API cannot be called with only the stepId and options . Authentication step filtering Filters out some of the authentication options of a step based on some condition. This can be achieved by specifying an array named \u2018 authenticationOptions \u2019 to the options map. Each array item will require an ' idp' for federated IdPs or an ' authenticator' for local authenticators. Example code executeStep(1,{ authenticationOptions:[{authenticator:'basic'},{idp:'google'}] } ,{ onSuccess: function (context) { // Do something on success };","title":"executeStep(stepId, options, eventCallbacks)"},{"location":"references/adaptive-authentication-js-api-reference/#utility-functions","text":"The implementation of utility functions can be found in the WSO2 extensions code repository .","title":"Utility functions"},{"location":"references/adaptive-authentication-js-api-reference/#hasroleuser-role","text":"This function returns true if the specified \u2018 user \u2019 belongs to the specified \u2018 role ', and returns false if the user does not. It includes the following parameters. Parameter Description user A user object representing the user details. role A string representing the role name. Example code var user = context.steps[1].subject; var isAdmin = hasRole(user, 'admin'); Log.info('--------------- Has Admin ' + isAdmin); if (isAdmin) { executeStep(2); }","title":"hasRole(user, role)"},{"location":"references/adaptive-authentication-js-api-reference/#assignuserrolesuser-assigningroles","text":"This function assigns each of the roles specified in the \u2018 assigningRoles \u2019 parameter to the specified \u2018 user \u2019 object. It returns true if all the roles are successfully assigned and returns false if not. It includes the following parameters. Parameter Description user An object representing the user details. assigningRoles A list of strings containing roles that are to be assigned where each string is a role name. executeStep(1, { onSuccess: function (context) { // Extracting authenticated subject from the first step. let user = context.currentKnownSubject; assignUserRoles(user, ['exampleRole1', 'exampleRole2']); } });","title":"assignUserRoles(user, assigningRoles)"},{"location":"references/adaptive-authentication-js-api-reference/#removeuserrolesuser-removingroles","text":"This function r emoves each of the roles specified in the \u2018 removingRoles \u2019 parameter to the given \u2018 user \u2019 object. It returns true if all the roles are successfully removed and returns false if not. It includes the following parameters. Parameter Description user An object representing the user details. removingRoles A list of strings that containing roles that are to be removed where each string is a role name. executeStep(1, { onSuccess: function (context) { // Extracting authenticated subject from the first step. let user = context.currentKnownSubject; removeUserRoles(user, ['exampleRole1', 'exampleRole2']); } });","title":"removeUserRoles(user, removingRoles)"},{"location":"references/adaptive-authentication-js-api-reference/#sendemailuser-templateid-placeholderparameters","text":"This function sends an email to the specified user. It includes the following parameters. Parameter Description user An object representing the user details. templateId Identifier of the email template. The email template specifies the body of the email that is sent out. placeholderParameters Used to replace any placeholders in the template. Example code var user = context.steps[1].subject; var firstName = user.localClaims['http://wso2.org/claims/givenname']; sendEmail(user, 'myTemplate', {'firstName':firstName});","title":"sendEmail(user, templateId, placeholderParameters)"},{"location":"references/adaptive-authentication-js-api-reference/#senderrorurlparameters","text":"This function redirects the user to an error page. It includes the following parameters. Parameter Description url The URL of the error page that the user is redirected to. If the value is null, the user is redirected by default to the ' retry.do' error page. Note that any relative URL is assumed as the relative to host\u2019s root. parameters Key value map passed as parameters. These are converted to query parameters in the URL. Example code var user = context.steps[1].subject; var isAdmin = hasRole(user, 'admin'); if (!isAdmin) { sendError('http://www.example.com/error',{'errorcode':'000403','errorMsg':'You are not allowed to login to this app.'}); } Tip Tip : When passing error messages to the error page, it is recommended to use the i18n key so that it can be internationalized easily at the page.","title":"sendError(url,parameters)"},{"location":"references/adaptive-authentication-js-api-reference/#setcookieresponse-name-value-properties","text":"This functions sets a new cookie. It includes the following parameters. Parameter Description name Name of the cookie. value Value of the cookie. properties A map that may contain optional attributes of the cookie with two other custom attributes \u2018 encrypt \u2019 and \u2018 sign \u2019. The default value of ' sign ' is false. If it is set to true, the value will be signed. The default value of ' encrypt ' is false. If it is set to true, value will be encrypted. Tip The size of the value has to be less than the RSA key pair length if ' encrypt ' is enabled (set to true). setCookie(context.response, name , test , { max-age : 4000, path : / , domain : localhost , httpOnly : true, secure : true, version : 1, comment : some comments , encrypt : true, sign : true})","title":"setCookie(response, name, value, properties)"},{"location":"references/adaptive-authentication-js-api-reference/#getcookievaluerequest-name-properties","text":"This function gets the plain-text cookie value for the cookie \u2018 name \u2019 if present. It includes the following parameters. Parameter Description name Name of the cookie. value Value of the cookie. properties A map that may contain optional attributes of the cookie \u2018 de crypt validateSignature The default value of ' decrypt ' is false. If it is set to true, the value will be decrypted. The default value of ' validateSignature ' is false. If it is set to true, the signature will be validated before returning a response. getCookieValue(context.request, name , { decrypt : true, validateSignature : true })","title":"getCookieValue(request, name, properties)"},{"location":"references/adaptive-authentication-js-api-reference/#callanalytics-metadata-payloaddata-eventhandlers","text":"This function calls the analytics engine (i.e., WSO2 Stream Processor) to get a decision. It includes the following parameters. Parameter Description metadata A JSON object that contain the following attributes: Application: Siddhi application name (mandatory) InputStream: Input stream name (mandatory) payloadData The data that needs to be sent to the analytics engine. eventHandlers The callback event handlers.","title":"callAnalytics( metadata, payloadData, eventHandlers )"},{"location":"references/adaptive-authentication-js-api-reference/#publishtoanalytics-metadata-payloaddata","text":"This function publishes data to the analytics engine (WSO2 Stream Processor). It includes the following parameters. Parameter Description metadata A JSON object that contain the following attributes: Application: Siddhi application name (mandatory) InputStream: Input stream name (mandatory) payloadData The data that needs to be sent to the analytics engine.","title":"publishToAnalytics( metadata, payloadData )"},{"location":"references/adaptive-authentication-js-api-reference/#prompttemplateid-data-eventhandlers","text":"This function prompts for user input. It includes the following parameters. Parameter Description templateId Identifier of the template that needs to be prompted. data The data to send to the prompt. eventHandlers The callback event handlers. function onLoginRequest(context) { executeStep(1, { onSuccess: function (context) { var username = context.steps[1].subject.username; prompt( genericForm , { username :username, inputs :[{ id :fname, label : First Name },{ id :lname, label : Last Name }]}, { onSuccess : function(context) { var fname = context.request.params.fname[0]; var lname = context.request.params.lname[0]; Log.info(fname); Log.info(lname); } }); } }); }","title":"prompt(templateId, data, eventHandlers)"},{"location":"references/adaptive-authentication-js-api-reference/#object-reference","text":"","title":"Object Reference"},{"location":"references/adaptive-authentication-js-api-reference/#context-object","text":"Contains the authentication context information. The information can be accessed as follows. context.steps[ n ] : Access the authentication step information, where n is the step number (1-based). See step Object for more information. Note Note : The step number is the one configured at the step configuration, not the actual order in which they get executed. context.request : Access the HTTP authentication request information. See request Object for more information. context.response : Access the HTTP response which will be sent back to the client. See response Object for more information. context.serviceProviderName : Get the application name.","title":"context Object"},{"location":"references/adaptive-authentication-js-api-reference/#step-object","text":"Contains the authentication step information. May be null or invalid step number. step.subject : Contains the authenticated user\u2019s information from this step. May be null if the step is not yet executed. See user Object for more information. step.idp : Gives the Idp name which was used to authenticate this user.","title":"step Object"},{"location":"references/adaptive-authentication-js-api-reference/#user-object","text":"user.username : The user\u2019s username. user.tenantDomain : The user\u2019s tenant domain (only for local users; federated users will have this as carbon.super ). user.userStoreDomain : The user\u2019s user store domain (only for local users). user.roles : List of user\u2019s roles. user.localClaims[\u201c local_claim_url \u201d] : (Read/Write) User\u2019s attribute (claim) value for the given \u201clocal_claim_url\u201d. If the user is a federated user, this will be the value of the mapped remote claim from the IdP. user.remoteClaims[\u201c remote_claim_url\u201d] : (Read/Write) User\u2019s attribute (claim) as returned by IdP for the given \u201cremote_claim_url\u201d. Applicable only for federated users.","title":"user Object"},{"location":"references/adaptive-authentication-js-api-reference/#request-object","text":"request.headers[\u201c header_name \u201d] : Request\u2019s header value for the given header name by header_name request.params[\u201c param_name \u201d] : Request\u2019s parameter value for the given parameter name by parameter_name request.cookies[\u201c cookie_name\u201d] : Request\u2019s cookie value for the given cookie name by cookie_name request.ip : The client IP address of the user who initiated the request. If there are any load balancers (eg. Nginx) with connection termination, the ip is retrieved from the headers set by the load balancer.","title":"request Object"},{"location":"references/adaptive-authentication-js-api-reference/#response-object","text":"request.headers[\u201c header_name \u201d] : (Write) Response header value for the given header name by header_name","title":"response Object"},{"location":"references/api-permissions/","text":"API Permissions The following table lists out all the available APIs and their operations and specifies the permissions of each operation. Service Operation Permission Level IdentityProviderMgtService addIdP /permission/admin/manage deleteIdP /permission/admin/manage getAllFederatedAuthenticators /permission/admin/manage getAllIdPs /permission/admin/login getAllLocalClaimUris /permission/admin/manage getAllProvisioningConnectors /permission/admin/manage getEnabledAllIdPs /permission/admin/manage getIdPByName /permission/admin/manage getResidentIdP /permission/admin/manage updateIdP /permission/admin/manage updateResidentIdP /permission/admin/manage IdentityApplicationManagementService createApplication /permission/admin/manage deleteApplication /permission/admin/manage getAllApplicationBasicInfo /permission/admin/manage getAllIdentityProviders /permission/admin/manage getAllLocalAuthenticators /permission/admin/manage getAllLocalClaimUris /permission/admin/manage getAllRequestPathAuthenticators /permission/admin/manage getApplication /permission/admin/manage getIdentityProvider /permission/admin/manage updateApplication /permission/admin/manage TenantMgtAdminService activateTenant /permission/protected/manage/modify/tenants addSkeletonTenant /permission/protected/manage/monitor/tenants addTenant /permission/protected/manage/monitor/tenants deactivateTenant /permission/protected/manage/modify/tenants deleteTenant /permission/protected/manage/modify/tenants getTenant /permission/protected/manage/monitor/tenants retrievePaginatedPartialSearchTenants /permission/protected/manage/monitor/tenants retrievePaginatedTenants /permission/protected/manage/monitor/tenants retrievePartialSearchTenants /permission/protected/manage/monitor/tenants retrieveTenants /permission/protected/manage/monitor/tenants updateTenant /permission/protected/manage/modify/tenants UserStoreConfigAdminService addUserStore /permission/admin/manage/identity/userstore/config/create changeUserStoreState /permission/admin/manage/identity/userstore/config/update deleteUserStore /permission/admin/manage/identity/userstore/config/delete deleteUserStoresSet /permission/admin/manage/identity/userstore/config/delete editUserStore /permission/admin/manage/identity/userstore/config/update editUserStoreWithDomainName /permission/admin/manage/identity/userstore/config/update getAvailableUserStoreClasses /permission/admin/manage/identity/userstore/config/view getSecondaryRealmConfigurations /permission/admin/manage/identity/userstore/config/view getUserStoreManagerProperties /permission/admin/manage/identity/userstore/config/view testRDBMSConnection /permission/admin/manage/identity/userstore/config/view OAuthAdminService getAllOAuthApplicationData /permission/admin/manage/identity/applicationmgt/view getAllowedGrantTypes /permission/admin/manage/identity/applicationmgt/view getAppsAuthorizedByUser /permission/admin/login getOAuthApplicationData /permission/admin/manage/identity/applicationmgt/view getOAuthApplicationDataByAppName /permission/admin/manage/identity/applicationmgt/view registerOAuthApplicationData /permission/admin/manage/identity/applicationmgt/create registerOAuthConsumer /permission/admin/manage/identity/applicationmgt/create removeOAuthApplicationData /permission/admin/manage/identity/applicationmgt/delete revokeAuthzForAppsByResoureOwner /permission/admin/login updateConsumerApplication /permission/admin/manage/identity/applicationmgt/update OAuth2TokenValidationService findOAuthConsumerIfTokenIsValid /permission/admin/manage validate /permission/admin/manage ClaimManagementService addNewClaimDialect /permission/admin/configure/security addNewClaimMapping /permission/admin/configure/security getClaimMappingByDialect /permission/admin/configure/security getClaimMappings /permission/admin/configure/security removeClaimDialect /permission/admin/configure/security removeClaimMapping /permission/admin/configure/security upateClaimMapping /permission/admin/configure/security RemoteUserStoreManagerService addRole /permission/admin/configure/security addUser /permission/admin/configure/security addUserClaimValue /permission/admin/configure/security addUserClaimValues /permission/admin/configure/security authenticate /permission/admin/configure/security deleteRole /permission/admin/configure/security deleteUser /permission/admin/configure/security deleteUserClaimValue /permission/admin/configure/security deleteUserClaimValues /permission/admin/configure/security getAllProfileNames /permission/admin/configure/security getHybridRoles /permission/admin/configure/security getPasswordExpirationTime /permission/admin/configure/security getProfileNames /permission/admin/configure/security getProperties /permission/admin/configure/security getRoleListOfUser /permission/admin/configure/security getRoleNames /permission/admin/configure/security getTenantId /permission/admin/configure/security getTenantIdofUser /permission/admin/configure/security getUserClaimValue /permission/admin/configure/security getUserClaimValues /permission/admin/configure/security getUserClaimValuesForClaims /permission/admin/configure/security getUserId /permission/admin/configure/security getUserList /permission/admin/configure/security getUserListOfRole /permission/admin/configure/security isExistingRole /permission/admin/configure/security isExistingUser /permission/admin/configure/security isReadOnly /permission/admin/configure/security listUsers /permission/admin/configure/security setUserClaimValue /permission/admin/configure/security setUserClaimValues /permission/admin/configure/security updateCredential /permission/admin/configure/security updateCredentialByAdmin /permission/admin/configure/security updateRoleListOfUser /permission/admin/configure/security updateRoleName /permission/admin/configure/security updateUserListOfRole /permission/admin/configure/security RemoteAuthorizationManagerService authorizeRole /permission/admin/configure/security authorizeUser /permission/admin/configure/security clearAllRoleAuthorization /permission/admin/configure/security clearAllUserAuthorization /permission/admin/configure/security clearResourceAuthorizations /permission/admin/configure/security clearRoleActionOnAllResources /permission/admin/configure/security clearRoleAuthorization /permission/admin/configure/security clearUserAuthorization /permission/admin/configure/security denyRole /permission/admin/configure/security denyUser /permission/admin/configure/security getAllowedRolesForResource /permission/admin/configure/security getAllowedUIResourcesForUser /permission/admin/configure/security getDeniedRolesForResource /permission/admin/configure/security getExplicitlyAllowedUsersForResource /permission/admin/configure/security getExplicitlyDeniedUsersForResource /permission/admin/configure/security isRoleAuthorized /permission/admin/configure/security isUserAuthorized /permission/admin/manage/identity resetPermissionOnUpdateRole /permission/admin/configure/security RemoteProfileConfigurationManagerService addProfileConfig /permission/admin/configure/security deleteProfileConfig /permission/admin/configure/security getAllProfiles /permission/admin/configure/security getProfileConfig /permission/admin/configure/security updateProfileConfig /permission/admin/configure/security RemoteClaimManagerService addNewClaimMapping /permission/admin/configure/security deleteClaimMapping /permission/admin/configure/security getAllClaimMappings /permission/admin/configure/security getAllClaimUris /permission/admin/configure/security getAllRequiredClaimMappings /permission/admin/configure/security getAllSupportClaimMappingsByDefault /permission/admin/configure/security getAttributeName /permission/admin/configure/security getAttributeNameFromDomain /permission/admin/configure/security getClaim /permission/admin/configure/security getClaimMapping /permission/admin/configure/security updateClaimMapping /permission/admin/configure/security RemoteUserRealmService getRealmConfiguration /permission/protected/tenant-admin RemoteTenantManagerService activateTenant /permission/protected/tenant-admin addTenant /permission/protected/tenant-admin deactivateTenant /permission/protected/tenant-admin deleteTenant /permission/protected/tenant-admin getAllTenants /permission/protected/tenant-admin getDomain /permission/protected/tenant-admin getSuperTenantDomain /permission/protected/tenant-admin getTenant /permission/protected/tenant-admin getTenantId /permission/protected/tenant-admin isTenantActive /permission/protected/tenant-admin updateTenant /permission/protected/tenant-admin UserIdentityManagementAdminService changeUserPassword /permission/admin/login deleteUser /permission/admin/login getAllChallengeQuestions /permission/admin/login getAllPromotedUserChallenge /permission/admin/login getAllUserIdentityClaims /permission/admin/login getChallengeQuestionsOfUser /permission/admin/login isReadOnlyUserStore /permission/admin/login lockUserAccount /permission/admin/login resetUserPassword /permission/admin/login setChallengeQuestions /permission/admin/login setChallengeQuestionsOfUser /permission/admin/login unlockUserAccount /permission/admin/login updateUserIdentityClaims /permission/admin/login AccountCredentialMgtConfigService getEmailConfig /permission/admin/login saveEmailConfig /permission/admin/login UserInformationRecoveryService confirmUserSelfRegistration /permission/admin/login getAllChallengeQuestions /permission/admin/login getCaptcha /permission/admin/login getUserChallengeQuestion /permission/admin/login getUserChallengeQuestionIds /permission/admin/login getUserIdentitySupportedClaims /permission/admin/login registerUser /permission/admin/login sendRecoveryNotification /permission/admin/login updatePassword /permission/admin/login verifyAccount /permission/admin/login verifyConfirmationCode /permission/admin/login verifyUser /permission/admin/login verifyUserChallengeAnswer /permission/admin/login EntitlementAdminService clearAllAttributeCaches /permission/admin/configure clearAllResourceCaches /permission/admin/configure clearAttributeFinderCache /permission/admin/configure clearAttributeFinderCacheByAttributes /permission/admin/configure clearCarbonAttributeCache /permission/admin/configure clearCarbonResourceCache /permission/admin/configure clearDecisionCache /permission/admin/configure clearPolicyCache /permission/admin/configure clearResourceFinderCache /permission/admin/configure doTestRequest /permission/admin/configure doTestRequestForGivenPolicies /permission/admin/configure getGlobalPolicyAlgorithm /permission/admin/configure getPDPData /permission/admin/configure getPIPAttributeFinderData /permission/admin/configure getPIPResourceFinderData /permission/admin/configure getPolicyFinderData /permission/admin/configure refreshAttributeFinder /permission/admin/configure refreshPolicyFinders /permission/admin/configure refreshResourceFinder /permission/admin/configure setGlobalPolicyAlgorithm /permission/admin/configure EntitlementPolicyAdminService addPolicies /permission/admin/configure addPolicy /permission/admin/configure addSubscriber /permission/admin/configure deleteSubscriber /permission/admin/configure dePromotePolicy /permission/admin/configure enableDisablePolicy /permission/admin/configure getAllPolicies /permission/admin/configure getAllPolicyIds /permission/admin/configure getEntitlementData /permission/admin/configure getEntitlementDataModules /permission/admin/configure getLightPolicy /permission/admin/configure getPolicy /permission/admin/configure getPolicyByVersion /permission/admin/configure getPolicyVersions /permission/admin/configure getPublisherModuleData /permission/admin/configure getStatusData /permission/admin/configure getSubscriber /permission/admin/configure getSubscriberIds /permission/admin/configure importPolicyFromRegistry /permission/admin/configure orderPolicy /permission/admin/configure publish /permission/admin/configure publishPolicies /permission/admin/configure publishToPDP /permission/admin/configure removePolicies /permission/admin/configure removePolicy /permission/admin/configure rollBackPolicy /permission/admin/configure updatePolicy /permission/admin/configure updateSubscriber /permission/admin/configure EntitlementService getAllEntitlements /permission/admin/login getBooleanDecision /permission/admin/login getDecision /permission/admin/login getDecisionByAttributes /permission/admin/login getEntitledAttributes /permission/admin/login XACMLAuthzDecisionQuery /permission/admin/login ws-xacml XACMLAuthzDecisionQuery /permission/admin/manage UserProfileMgtService associateID /permission/admin/login deleteUserProfile /permission/admin/login getAssociatedIDs /permission/admin/login getInstance /permission/admin/login getNameAssociatedWith /permission/admin/login getProfileFieldsForInternalStore /permission/admin/login getUserProfile /permission/admin/login getUserProfiles /permission/admin/login isAddProfileEnabled /permission/admin/login isAddProfileEnabledForDomain /permission/admin/login isReadOnlyUserStore /permission/admin/login removeAssociateID /permission/admin/login setUserProfile /permission/admin/login UserAdmin addInternalRole /permission/admin/configure/security addRemoveRolesOfUser /permission/admin/configure/security addRemoveUsersOfRole /permission/admin/configure/security addRole /permission/admin/configure/security addUser /permission/admin/configure/security/usermgt/users bulkImportUsers /permission/admin/configure/security changePassword /permission/admin/configure/security/usermgt/passwords changePasswordByUser /permission/admin/login deleteRole /permission/admin/configure/security deleteUser /permission/admin/configure/security/usermgt/users getAllRolesNames /permission/admin/configure/security/rolemgt,/permission/admin/manage/modify/service getAllSharedRoleNames /permission/admin/configure/security getAllUIPermissions /permission/admin/configure/security getRolePermissions /permission/admin/configure/security getRolesOfCurrentUser /permission/admin/login getRolesOfUser /permission/admin/configure/security getUserRealmInfo /permission/admin/login getUsersOfRole /permission/admin/configure/security/rolemgt hasMultipleUserStores /permission/admin/login isSharedRolesEnabled /permission/admin/configure/security listAllUsers /permission/admin/configure/security/usermgt/users,/permission/admin/configure/security/usermgt/passwords,/permission/admin/configure/security/usermgt/profiles listUserByClaim /permission/admin/configure/security listUsers /permission/admin/configure/security/usermgt/users,/permission/admin/configure/security/usermgt/passwords,/permission/admin/configure/security/usermgt/profiles setRoleUIPermission /permission/admin/configure/security updateRoleName /permission/admin/configure/security updateRolesOfUser /permission/admin/configure/security updateUsersOfRole /permission/admin/configure/security MultipleCredentialsUserAdmin addCredential /permission/admin/configure/security/usermgt/passwords addUser /permission/admin/configure/security/usermgt/users addUsers /permission/admin/configure/security/usermgt/users addUserWithUserId /permission/admin/configure/security/usermgt authenticate /permission/admin/configure/security/usermgt deleteCredential /permission/admin/configure/security/usermgt/passwords deleteUser /permission/admin/configure/security/usermgt/users deleteUserClaimValue /permission/admin/configure/security/usermgt deleteUserClaimValues /permission/admin/configure/security/usermgt getAllUserClaimValues /permission/admin/login getCredentials /permission/admin/configure/security/usermgt/passwords getUserClaimValue /permission/admin/configure/security/usermgt getUserClaimValues /permission/admin/configure/security/usermgt getUserId /permission/admin/configure/security/usermgt setUserClaimValue /permission/admin/configure/security/usermgt setUserClaimValues /permission/admin/configure/security/usermgt updateCredential /permission/admin/configure/security/usermgt/passwords IdentityProviderAdminService addOpenID /permission/admin/login extractPrimaryUserName /permission/admin/login getAllOpenIDs /permission/admin/login getPrimaryOpenID /permission/admin/login removeOpenID /permission/admin/login XMPPConfigurationService addUserXmppSettings /permission/admin/login editXmppSettings /permission/admin/login getUserIM /permission/admin/login getXmppSettings /permission/admin/login hasXMPPSettings /permission/admin/login isXMPPSettingsEnabled /permission/admin/login IdentitySAMLSSOConfigService addRPServiceProvider /permission/admin/manage getCertAliasOfPrimaryKeyStore /permission/admin/manage getClaimURIs /permission/admin/manage getServiceProviders /permission/admin/manage removeServiceProvider /permission/admin/manage IdentitySTSAdminService readCardIssuerConfiguration /permission/admin/manage updateCardIssueConfiguration /permission/admin/manage IWAAuthenticator canHandle /permission/admin/login login /permission/admin/login ProvisioningAdminService getAllInstalledFeatures /permission/protected/configure/components getInstalledFeatureInfo /permission/protected/configure/components getInstalledFeaturesWithProperty /permission/protected/configure/components getLicensingInformation /permission/protected/configure/components getProfileHistory /permission/protected/configure/components performProvisioningAction /permission/protected/configure/components removeAllConsoleFeatures /permission/protected/configure/components removeAllServerFeatures /permission/protected/configure/components reviewProvisioningAction /permission/protected/configure/components ProfilesAdminService getUserProfile /permission/admin/manage/modify/user-profile putUserProfile /permission/admin/manage/modify/user-profile SecurityAdminService activateUsernameTokenAuthentication /permission/admin/manage/modify/service applyKerberosSecurityPolicy /permission/admin/manage/modify/service applySecurity /permission/admin/manage/modify/service disableSecurityOnService /permission/admin/manage/modify/service getScenarios /permission/admin/manage/modify/service getSecurityConfigData /permission/admin/manage/modify/service getSecurityScenario /permission/admin/manage/modify/service STSAdminService addTrustedService /permission/admin/configure/security getCertAliasOfPrimaryKeyStore /permission/admin/configure/security getProofKeyType /permission/admin/configure/security getTrustedServices /permission/admin/configure/security removeTrustedService /permission/admin/configure/security setProofKeyType /permission/admin/configure/security KeyStoreAdminService addKeyStore /permission/admin/configure/security addTrustStore /permission/admin/configure/security deleteStore /permission/admin/configure/security getKeystoreInfo /permission/admin/configure/security getKeyStores /permission/admin/configure/security,/permission/admin/manage/modify/service getPaginatedKeystoreInfo /permission/admin/configure/security getStoreEntries /permission/admin/configure/security importCertToStore /permission/admin/configure/security removeCertFromStore /permission/admin/configure/security SCIMConfigAdminService addGlobalProvider /permission/admin/configure/security addUserProvider /permission/admin/configure/security/usermgt/provisioning deleteGlobalProvider /permission/admin/configure/security deleteUserProvider /permission/admin/configure/security/usermgt/provisioning getAllGlobalProviders /permission/admin/configure/security getAllUserProviders /permission/admin/configure/security/usermgt/provisioning getGlobalProvider /permission/admin/configure/security getUserProvider /permission/admin/configure/security/usermgt/provisioning updateGlobalProvider /permission/admin/configure/security updateUserProvider /permission/admin/configure/security/usermgt/provisioning DirectoryServerManager addServer /permission/admin/configure/security,/permission/admin/manage/modify/service changePassword /permission/admin/configure/security,/permission/admin/manage/modify/service getPasswordConformanceRegularExpression /permission/admin/configure/security,/permission/admin/manage/modify/service getServiceNameConformanceRegularExpression /permission/admin/configure/security,/permission/admin/manage/modify/service isExistingServicePrinciple /permission/admin/configure/security,/permission/admin/manage/modify/service isKDCEnabled /permission/admin/configure/security,/permission/admin/manage/modify/service listServicePrinciples /permission/admin/configure/security,/permission/admin/manage/modify/service removeServer /permission/admin/configure/security,/permission/admin/manage/modify/service LoggedUserInfoAdmin getUserInfo /permission/admin/login LoggingAdmin getAllLoggerData /permission/protected/configure/logging getAppenderData /permission/protected/configure/logging getLoggerData /permission/protected/configure/logging getSyslogData /permission/protected/configure/logging getSystemLog /permission/protected/configure/logging isStratosService /permission/protected/configure/logging removeSyslogPattern /permission/protected/configure/logging restoreDefaults /permission/protected/configure/logging updateAllAppenderData /permission/protected/configure/logging updateLoggerData /permission/protected/configure/logging updateSyslogConfig /permission/protected/configure/logging updateSystemLog /permission/protected/configure/logging LoginStatisticsAdmin getLoginAttempts Not available getUserBasedLoginAttempts Not available WorkflowAdminService getWorkflow /permission/admin/manage/identity/workflow/definition/view listWorkflowEvents /permission/admin/manage/identity/workflow/association/view listTemplates /permission/admin/manage/identity/workflow/definition/view getTemplate /permission/admin/manage/identity/workflow/definition/view getWorkflowImpl /permission/admin/manage/identity/workflow/definition/view listWorkflowImpls /permission/admin/manage/identity/workflow/definition/view addWorkflow /permission/admin/manage/identity/workflow/definition/create addAssociation /permission/admin/manage/identity/workflow/association/create changeAssociationState /permission/admin/manage/identity/workflow/association/update listWorkflows /permission/admin/manage/identity/workflow/definition/view removeWorkflow /permission/admin/manage/identity/workflow/definition/delete removeAssociation /permission/admin/manage/identity/workflow/association/delete listAssociations /permission/admin/manage/identity/workflow/association/view listAllAssociations /permission/admin/manage/identity/workflow/association/view getEvent /permission/admin/manage/identity/workflow/association/view getRequestsCreatedByUser /permission/admin/manage/identity/workflow/monitor/view getRequestsInFilter /permission/admin/manage/identity/workflow/monitor/view deleteWorkflowRequest /permission/admin/manage/identity/workflow/monitor/delete getWorkflowsOfRequest /permission/admin/manage/identity/workflow/monitor/view WorkflowImplAdminService addBPSProfile /permission/admin/manage/identity/workflow/profile/create listBPSProfiles /permission/admin/manage/identity/workflow/profile/view getBPSProfile /permission/admin/manage/identity/workflow/profile/view updateBPSProfile /permission/admin/manage/identity/workflow/profile/update removeBPSProfile /permission/admin/manage/identity/workflow/profile/delete removeBPSPackage /permission/admin/manage/identity/workflow/profile/delete","title":"API Permissions"},{"location":"references/api-permissions/#api-permissions","text":"The following table lists out all the available APIs and their operations and specifies the permissions of each operation. Service Operation Permission Level IdentityProviderMgtService addIdP /permission/admin/manage deleteIdP /permission/admin/manage getAllFederatedAuthenticators /permission/admin/manage getAllIdPs /permission/admin/login getAllLocalClaimUris /permission/admin/manage getAllProvisioningConnectors /permission/admin/manage getEnabledAllIdPs /permission/admin/manage getIdPByName /permission/admin/manage getResidentIdP /permission/admin/manage updateIdP /permission/admin/manage updateResidentIdP /permission/admin/manage IdentityApplicationManagementService createApplication /permission/admin/manage deleteApplication /permission/admin/manage getAllApplicationBasicInfo /permission/admin/manage getAllIdentityProviders /permission/admin/manage getAllLocalAuthenticators /permission/admin/manage getAllLocalClaimUris /permission/admin/manage getAllRequestPathAuthenticators /permission/admin/manage getApplication /permission/admin/manage getIdentityProvider /permission/admin/manage updateApplication /permission/admin/manage TenantMgtAdminService activateTenant /permission/protected/manage/modify/tenants addSkeletonTenant /permission/protected/manage/monitor/tenants addTenant /permission/protected/manage/monitor/tenants deactivateTenant /permission/protected/manage/modify/tenants deleteTenant /permission/protected/manage/modify/tenants getTenant /permission/protected/manage/monitor/tenants retrievePaginatedPartialSearchTenants /permission/protected/manage/monitor/tenants retrievePaginatedTenants /permission/protected/manage/monitor/tenants retrievePartialSearchTenants /permission/protected/manage/monitor/tenants retrieveTenants /permission/protected/manage/monitor/tenants updateTenant /permission/protected/manage/modify/tenants UserStoreConfigAdminService addUserStore /permission/admin/manage/identity/userstore/config/create changeUserStoreState /permission/admin/manage/identity/userstore/config/update deleteUserStore /permission/admin/manage/identity/userstore/config/delete deleteUserStoresSet /permission/admin/manage/identity/userstore/config/delete editUserStore /permission/admin/manage/identity/userstore/config/update editUserStoreWithDomainName /permission/admin/manage/identity/userstore/config/update getAvailableUserStoreClasses /permission/admin/manage/identity/userstore/config/view getSecondaryRealmConfigurations /permission/admin/manage/identity/userstore/config/view getUserStoreManagerProperties /permission/admin/manage/identity/userstore/config/view testRDBMSConnection /permission/admin/manage/identity/userstore/config/view OAuthAdminService getAllOAuthApplicationData /permission/admin/manage/identity/applicationmgt/view getAllowedGrantTypes /permission/admin/manage/identity/applicationmgt/view getAppsAuthorizedByUser /permission/admin/login getOAuthApplicationData /permission/admin/manage/identity/applicationmgt/view getOAuthApplicationDataByAppName /permission/admin/manage/identity/applicationmgt/view registerOAuthApplicationData /permission/admin/manage/identity/applicationmgt/create registerOAuthConsumer /permission/admin/manage/identity/applicationmgt/create removeOAuthApplicationData /permission/admin/manage/identity/applicationmgt/delete revokeAuthzForAppsByResoureOwner /permission/admin/login updateConsumerApplication /permission/admin/manage/identity/applicationmgt/update OAuth2TokenValidationService findOAuthConsumerIfTokenIsValid /permission/admin/manage validate /permission/admin/manage ClaimManagementService addNewClaimDialect /permission/admin/configure/security addNewClaimMapping /permission/admin/configure/security getClaimMappingByDialect /permission/admin/configure/security getClaimMappings /permission/admin/configure/security removeClaimDialect /permission/admin/configure/security removeClaimMapping /permission/admin/configure/security upateClaimMapping /permission/admin/configure/security RemoteUserStoreManagerService addRole /permission/admin/configure/security addUser /permission/admin/configure/security addUserClaimValue /permission/admin/configure/security addUserClaimValues /permission/admin/configure/security authenticate /permission/admin/configure/security deleteRole /permission/admin/configure/security deleteUser /permission/admin/configure/security deleteUserClaimValue /permission/admin/configure/security deleteUserClaimValues /permission/admin/configure/security getAllProfileNames /permission/admin/configure/security getHybridRoles /permission/admin/configure/security getPasswordExpirationTime /permission/admin/configure/security getProfileNames /permission/admin/configure/security getProperties /permission/admin/configure/security getRoleListOfUser /permission/admin/configure/security getRoleNames /permission/admin/configure/security getTenantId /permission/admin/configure/security getTenantIdofUser /permission/admin/configure/security getUserClaimValue /permission/admin/configure/security getUserClaimValues /permission/admin/configure/security getUserClaimValuesForClaims /permission/admin/configure/security getUserId /permission/admin/configure/security getUserList /permission/admin/configure/security getUserListOfRole /permission/admin/configure/security isExistingRole /permission/admin/configure/security isExistingUser /permission/admin/configure/security isReadOnly /permission/admin/configure/security listUsers /permission/admin/configure/security setUserClaimValue /permission/admin/configure/security setUserClaimValues /permission/admin/configure/security updateCredential /permission/admin/configure/security updateCredentialByAdmin /permission/admin/configure/security updateRoleListOfUser /permission/admin/configure/security updateRoleName /permission/admin/configure/security updateUserListOfRole /permission/admin/configure/security RemoteAuthorizationManagerService authorizeRole /permission/admin/configure/security authorizeUser /permission/admin/configure/security clearAllRoleAuthorization /permission/admin/configure/security clearAllUserAuthorization /permission/admin/configure/security clearResourceAuthorizations /permission/admin/configure/security clearRoleActionOnAllResources /permission/admin/configure/security clearRoleAuthorization /permission/admin/configure/security clearUserAuthorization /permission/admin/configure/security denyRole /permission/admin/configure/security denyUser /permission/admin/configure/security getAllowedRolesForResource /permission/admin/configure/security getAllowedUIResourcesForUser /permission/admin/configure/security getDeniedRolesForResource /permission/admin/configure/security getExplicitlyAllowedUsersForResource /permission/admin/configure/security getExplicitlyDeniedUsersForResource /permission/admin/configure/security isRoleAuthorized /permission/admin/configure/security isUserAuthorized /permission/admin/manage/identity resetPermissionOnUpdateRole /permission/admin/configure/security RemoteProfileConfigurationManagerService addProfileConfig /permission/admin/configure/security deleteProfileConfig /permission/admin/configure/security getAllProfiles /permission/admin/configure/security getProfileConfig /permission/admin/configure/security updateProfileConfig /permission/admin/configure/security RemoteClaimManagerService addNewClaimMapping /permission/admin/configure/security deleteClaimMapping /permission/admin/configure/security getAllClaimMappings /permission/admin/configure/security getAllClaimUris /permission/admin/configure/security getAllRequiredClaimMappings /permission/admin/configure/security getAllSupportClaimMappingsByDefault /permission/admin/configure/security getAttributeName /permission/admin/configure/security getAttributeNameFromDomain /permission/admin/configure/security getClaim /permission/admin/configure/security getClaimMapping /permission/admin/configure/security updateClaimMapping /permission/admin/configure/security RemoteUserRealmService getRealmConfiguration /permission/protected/tenant-admin RemoteTenantManagerService activateTenant /permission/protected/tenant-admin addTenant /permission/protected/tenant-admin deactivateTenant /permission/protected/tenant-admin deleteTenant /permission/protected/tenant-admin getAllTenants /permission/protected/tenant-admin getDomain /permission/protected/tenant-admin getSuperTenantDomain /permission/protected/tenant-admin getTenant /permission/protected/tenant-admin getTenantId /permission/protected/tenant-admin isTenantActive /permission/protected/tenant-admin updateTenant /permission/protected/tenant-admin UserIdentityManagementAdminService changeUserPassword /permission/admin/login deleteUser /permission/admin/login getAllChallengeQuestions /permission/admin/login getAllPromotedUserChallenge /permission/admin/login getAllUserIdentityClaims /permission/admin/login getChallengeQuestionsOfUser /permission/admin/login isReadOnlyUserStore /permission/admin/login lockUserAccount /permission/admin/login resetUserPassword /permission/admin/login setChallengeQuestions /permission/admin/login setChallengeQuestionsOfUser /permission/admin/login unlockUserAccount /permission/admin/login updateUserIdentityClaims /permission/admin/login AccountCredentialMgtConfigService getEmailConfig /permission/admin/login saveEmailConfig /permission/admin/login UserInformationRecoveryService confirmUserSelfRegistration /permission/admin/login getAllChallengeQuestions /permission/admin/login getCaptcha /permission/admin/login getUserChallengeQuestion /permission/admin/login getUserChallengeQuestionIds /permission/admin/login getUserIdentitySupportedClaims /permission/admin/login registerUser /permission/admin/login sendRecoveryNotification /permission/admin/login updatePassword /permission/admin/login verifyAccount /permission/admin/login verifyConfirmationCode /permission/admin/login verifyUser /permission/admin/login verifyUserChallengeAnswer /permission/admin/login EntitlementAdminService clearAllAttributeCaches /permission/admin/configure clearAllResourceCaches /permission/admin/configure clearAttributeFinderCache /permission/admin/configure clearAttributeFinderCacheByAttributes /permission/admin/configure clearCarbonAttributeCache /permission/admin/configure clearCarbonResourceCache /permission/admin/configure clearDecisionCache /permission/admin/configure clearPolicyCache /permission/admin/configure clearResourceFinderCache /permission/admin/configure doTestRequest /permission/admin/configure doTestRequestForGivenPolicies /permission/admin/configure getGlobalPolicyAlgorithm /permission/admin/configure getPDPData /permission/admin/configure getPIPAttributeFinderData /permission/admin/configure getPIPResourceFinderData /permission/admin/configure getPolicyFinderData /permission/admin/configure refreshAttributeFinder /permission/admin/configure refreshPolicyFinders /permission/admin/configure refreshResourceFinder /permission/admin/configure setGlobalPolicyAlgorithm /permission/admin/configure EntitlementPolicyAdminService addPolicies /permission/admin/configure addPolicy /permission/admin/configure addSubscriber /permission/admin/configure deleteSubscriber /permission/admin/configure dePromotePolicy /permission/admin/configure enableDisablePolicy /permission/admin/configure getAllPolicies /permission/admin/configure getAllPolicyIds /permission/admin/configure getEntitlementData /permission/admin/configure getEntitlementDataModules /permission/admin/configure getLightPolicy /permission/admin/configure getPolicy /permission/admin/configure getPolicyByVersion /permission/admin/configure getPolicyVersions /permission/admin/configure getPublisherModuleData /permission/admin/configure getStatusData /permission/admin/configure getSubscriber /permission/admin/configure getSubscriberIds /permission/admin/configure importPolicyFromRegistry /permission/admin/configure orderPolicy /permission/admin/configure publish /permission/admin/configure publishPolicies /permission/admin/configure publishToPDP /permission/admin/configure removePolicies /permission/admin/configure removePolicy /permission/admin/configure rollBackPolicy /permission/admin/configure updatePolicy /permission/admin/configure updateSubscriber /permission/admin/configure EntitlementService getAllEntitlements /permission/admin/login getBooleanDecision /permission/admin/login getDecision /permission/admin/login getDecisionByAttributes /permission/admin/login getEntitledAttributes /permission/admin/login XACMLAuthzDecisionQuery /permission/admin/login ws-xacml XACMLAuthzDecisionQuery /permission/admin/manage UserProfileMgtService associateID /permission/admin/login deleteUserProfile /permission/admin/login getAssociatedIDs /permission/admin/login getInstance /permission/admin/login getNameAssociatedWith /permission/admin/login getProfileFieldsForInternalStore /permission/admin/login getUserProfile /permission/admin/login getUserProfiles /permission/admin/login isAddProfileEnabled /permission/admin/login isAddProfileEnabledForDomain /permission/admin/login isReadOnlyUserStore /permission/admin/login removeAssociateID /permission/admin/login setUserProfile /permission/admin/login UserAdmin addInternalRole /permission/admin/configure/security addRemoveRolesOfUser /permission/admin/configure/security addRemoveUsersOfRole /permission/admin/configure/security addRole /permission/admin/configure/security addUser /permission/admin/configure/security/usermgt/users bulkImportUsers /permission/admin/configure/security changePassword /permission/admin/configure/security/usermgt/passwords changePasswordByUser /permission/admin/login deleteRole /permission/admin/configure/security deleteUser /permission/admin/configure/security/usermgt/users getAllRolesNames /permission/admin/configure/security/rolemgt,/permission/admin/manage/modify/service getAllSharedRoleNames /permission/admin/configure/security getAllUIPermissions /permission/admin/configure/security getRolePermissions /permission/admin/configure/security getRolesOfCurrentUser /permission/admin/login getRolesOfUser /permission/admin/configure/security getUserRealmInfo /permission/admin/login getUsersOfRole /permission/admin/configure/security/rolemgt hasMultipleUserStores /permission/admin/login isSharedRolesEnabled /permission/admin/configure/security listAllUsers /permission/admin/configure/security/usermgt/users,/permission/admin/configure/security/usermgt/passwords,/permission/admin/configure/security/usermgt/profiles listUserByClaim /permission/admin/configure/security listUsers /permission/admin/configure/security/usermgt/users,/permission/admin/configure/security/usermgt/passwords,/permission/admin/configure/security/usermgt/profiles setRoleUIPermission /permission/admin/configure/security updateRoleName /permission/admin/configure/security updateRolesOfUser /permission/admin/configure/security updateUsersOfRole /permission/admin/configure/security MultipleCredentialsUserAdmin addCredential /permission/admin/configure/security/usermgt/passwords addUser /permission/admin/configure/security/usermgt/users addUsers /permission/admin/configure/security/usermgt/users addUserWithUserId /permission/admin/configure/security/usermgt authenticate /permission/admin/configure/security/usermgt deleteCredential /permission/admin/configure/security/usermgt/passwords deleteUser /permission/admin/configure/security/usermgt/users deleteUserClaimValue /permission/admin/configure/security/usermgt deleteUserClaimValues /permission/admin/configure/security/usermgt getAllUserClaimValues /permission/admin/login getCredentials /permission/admin/configure/security/usermgt/passwords getUserClaimValue /permission/admin/configure/security/usermgt getUserClaimValues /permission/admin/configure/security/usermgt getUserId /permission/admin/configure/security/usermgt setUserClaimValue /permission/admin/configure/security/usermgt setUserClaimValues /permission/admin/configure/security/usermgt updateCredential /permission/admin/configure/security/usermgt/passwords IdentityProviderAdminService addOpenID /permission/admin/login extractPrimaryUserName /permission/admin/login getAllOpenIDs /permission/admin/login getPrimaryOpenID /permission/admin/login removeOpenID /permission/admin/login XMPPConfigurationService addUserXmppSettings /permission/admin/login editXmppSettings /permission/admin/login getUserIM /permission/admin/login getXmppSettings /permission/admin/login hasXMPPSettings /permission/admin/login isXMPPSettingsEnabled /permission/admin/login IdentitySAMLSSOConfigService addRPServiceProvider /permission/admin/manage getCertAliasOfPrimaryKeyStore /permission/admin/manage getClaimURIs /permission/admin/manage getServiceProviders /permission/admin/manage removeServiceProvider /permission/admin/manage IdentitySTSAdminService readCardIssuerConfiguration /permission/admin/manage updateCardIssueConfiguration /permission/admin/manage IWAAuthenticator canHandle /permission/admin/login login /permission/admin/login ProvisioningAdminService getAllInstalledFeatures /permission/protected/configure/components getInstalledFeatureInfo /permission/protected/configure/components getInstalledFeaturesWithProperty /permission/protected/configure/components getLicensingInformation /permission/protected/configure/components getProfileHistory /permission/protected/configure/components performProvisioningAction /permission/protected/configure/components removeAllConsoleFeatures /permission/protected/configure/components removeAllServerFeatures /permission/protected/configure/components reviewProvisioningAction /permission/protected/configure/components ProfilesAdminService getUserProfile /permission/admin/manage/modify/user-profile putUserProfile /permission/admin/manage/modify/user-profile SecurityAdminService activateUsernameTokenAuthentication /permission/admin/manage/modify/service applyKerberosSecurityPolicy /permission/admin/manage/modify/service applySecurity /permission/admin/manage/modify/service disableSecurityOnService /permission/admin/manage/modify/service getScenarios /permission/admin/manage/modify/service getSecurityConfigData /permission/admin/manage/modify/service getSecurityScenario /permission/admin/manage/modify/service STSAdminService addTrustedService /permission/admin/configure/security getCertAliasOfPrimaryKeyStore /permission/admin/configure/security getProofKeyType /permission/admin/configure/security getTrustedServices /permission/admin/configure/security removeTrustedService /permission/admin/configure/security setProofKeyType /permission/admin/configure/security KeyStoreAdminService addKeyStore /permission/admin/configure/security addTrustStore /permission/admin/configure/security deleteStore /permission/admin/configure/security getKeystoreInfo /permission/admin/configure/security getKeyStores /permission/admin/configure/security,/permission/admin/manage/modify/service getPaginatedKeystoreInfo /permission/admin/configure/security getStoreEntries /permission/admin/configure/security importCertToStore /permission/admin/configure/security removeCertFromStore /permission/admin/configure/security SCIMConfigAdminService addGlobalProvider /permission/admin/configure/security addUserProvider /permission/admin/configure/security/usermgt/provisioning deleteGlobalProvider /permission/admin/configure/security deleteUserProvider /permission/admin/configure/security/usermgt/provisioning getAllGlobalProviders /permission/admin/configure/security getAllUserProviders /permission/admin/configure/security/usermgt/provisioning getGlobalProvider /permission/admin/configure/security getUserProvider /permission/admin/configure/security/usermgt/provisioning updateGlobalProvider /permission/admin/configure/security updateUserProvider /permission/admin/configure/security/usermgt/provisioning DirectoryServerManager addServer /permission/admin/configure/security,/permission/admin/manage/modify/service changePassword /permission/admin/configure/security,/permission/admin/manage/modify/service getPasswordConformanceRegularExpression /permission/admin/configure/security,/permission/admin/manage/modify/service getServiceNameConformanceRegularExpression /permission/admin/configure/security,/permission/admin/manage/modify/service isExistingServicePrinciple /permission/admin/configure/security,/permission/admin/manage/modify/service isKDCEnabled /permission/admin/configure/security,/permission/admin/manage/modify/service listServicePrinciples /permission/admin/configure/security,/permission/admin/manage/modify/service removeServer /permission/admin/configure/security,/permission/admin/manage/modify/service LoggedUserInfoAdmin getUserInfo /permission/admin/login LoggingAdmin getAllLoggerData /permission/protected/configure/logging getAppenderData /permission/protected/configure/logging getLoggerData /permission/protected/configure/logging getSyslogData /permission/protected/configure/logging getSystemLog /permission/protected/configure/logging isStratosService /permission/protected/configure/logging removeSyslogPattern /permission/protected/configure/logging restoreDefaults /permission/protected/configure/logging updateAllAppenderData /permission/protected/configure/logging updateLoggerData /permission/protected/configure/logging updateSyslogConfig /permission/protected/configure/logging updateSystemLog /permission/protected/configure/logging LoginStatisticsAdmin getLoginAttempts Not available getUserBasedLoginAttempts Not available WorkflowAdminService getWorkflow /permission/admin/manage/identity/workflow/definition/view listWorkflowEvents /permission/admin/manage/identity/workflow/association/view listTemplates /permission/admin/manage/identity/workflow/definition/view getTemplate /permission/admin/manage/identity/workflow/definition/view getWorkflowImpl /permission/admin/manage/identity/workflow/definition/view listWorkflowImpls /permission/admin/manage/identity/workflow/definition/view addWorkflow /permission/admin/manage/identity/workflow/definition/create addAssociation /permission/admin/manage/identity/workflow/association/create changeAssociationState /permission/admin/manage/identity/workflow/association/update listWorkflows /permission/admin/manage/identity/workflow/definition/view removeWorkflow /permission/admin/manage/identity/workflow/definition/delete removeAssociation /permission/admin/manage/identity/workflow/association/delete listAssociations /permission/admin/manage/identity/workflow/association/view listAllAssociations /permission/admin/manage/identity/workflow/association/view getEvent /permission/admin/manage/identity/workflow/association/view getRequestsCreatedByUser /permission/admin/manage/identity/workflow/monitor/view getRequestsInFilter /permission/admin/manage/identity/workflow/monitor/view deleteWorkflowRequest /permission/admin/manage/identity/workflow/monitor/delete getWorkflowsOfRequest /permission/admin/manage/identity/workflow/monitor/view WorkflowImplAdminService addBPSProfile /permission/admin/manage/identity/workflow/profile/create listBPSProfiles /permission/admin/manage/identity/workflow/profile/view getBPSProfile /permission/admin/manage/identity/workflow/profile/view updateBPSProfile /permission/admin/manage/identity/workflow/profile/update removeBPSProfile /permission/admin/manage/identity/workflow/profile/delete removeBPSPackage /permission/admin/manage/identity/workflow/profile/delete","title":"API Permissions"},{"location":"references/config-catalog/","text":"Configuration Catalog This document describes all the configuration parameters that are used in WSO2 Identity Server. Instructions for use Select the configuration sections, parameters, and values that are required for your use and add them to the .toml file. See the example .toml file given below. # This is an example .toml file. [server] pattern= value enable_port_forward=true [key_mgr_node] endpoints= value [gateway] gateway_environments=[ dev , test ] [[database]] pool_options.maxActiv=5 Configuring the default deployment settings [server] Required This toml header groups the parameters that define the server node details. hostname string Required \"localhost\" The hostname of the WSO2 EI server instance. node_ip string Required \"127.0.0.1\" The IP address of the server node. enable_mtom boolean false Use this paramater to enable MTOM (Message Transmission Optimization Mechanism) for the product server. When MTOM is enabled. enable_swa boolean false Use this paramater to enable SwA (SOAP with Attachments) for the product server. When SwA is enabled, the ESB will process the files attached to SOAP messages. [server] hostname=\"localhost\" node_ip=\"127.0.0.1\" enable_mtom=false enable_swa=false Connecting to the primary data store [database.shared_db] The config heading that groups the parameters connecting the server to the primary database of the server. This database stores registry artifacts aswell as the user permissions that apply to user roles. By default, this also stores the user data unless a separate user store is configured using the [user_store] config section. type string Required \"H2\" The type of database that is used for the primary database. All the database types that are supported by this product is listed below as possible values. E.g. \"MySql\", \"Oracle\", \"Postgre\" Warning \"H2\" (not recommended for production environments). So please change when going on production. url string Required \"http://localhost:8082\" The connection URL of the database. Note that this is specific to the database type you are using. Use the URL pattern for the database type. username string Required wso2carbon The user name for connecting to the database. Any alpha numeric value. password string Required wso2carbon The password for connecting to the database. Any alpha numeric value. [database.shared_db] type=\"H2\" url=\"http://localhost:8082\" username=wso2carbon password=wso2carbon Tuning the primary data store connection Config Heading [database.shared_db.pool_options] The config heading in the ei.toml file that groups the parameters for tuning the performance of the primary database that you configured with the [database.shared_db] section. Default Enabled with default parameters. Mandatory Parameters maxActive The maximum number of active connections that can be allocated at the same time from the pool. If there are too many active connections in the connection pool, some of them would be idle, incurring an unnecessary system overhead. Default \"50\" Possible Values Depends on environment. Enter any negative value to denote an unlimited number of active connections. Optional maxWait The maximum number of milliseconds that the pool will wait (when there are no available connections) for a connection to be returned before throwing an exception. Default \"6000\" Possible Values Depends on environment. Enter zero or a negative value to wait indefinitely. Optional testOnBorrow The indication of whether objects will be validated before being borrowed from the pool. If the object fails to validate, it will be dropped from the pool, and another attempt will be made to borrow another. Default Enabled Possible Value Use \"false\" to disable testOnBorrow. Optional validationInterval The indication to avoid excess validation, and only run validation at the most, at this frequency (time in milliseconds). If a connection is due for validation but has been validated previously within this interval, it will not be validated again. Default \"30000\" Possible Values Depends on environment. Optional defaultAutoCommit Specifies whether each SQL statement should be automatically committed when it is completed. It is recommended to disable auto committing by setting this property to true. Default Enabled Possible Values Use \"false\" to disable default auto commit. Optional Connecting to the user stores Config Heading [user_store] The config heading in the ei.toml that connects the server to the user store. The user store holds the users and roles defined for the system. Default Enabled Mandatory Parameters type The type of user store. Default Value : \"database\" Possible Values : \"database\" , \"LDAP\" Mandatory Configuring the system administrator Config Heading [super_admin] : The config heading in the ei.toml file that groups the parameters defining the system adminsitrator. Default Enabled with the default parameters. Mandatory Parameters username The user name of the system administrator. This user has all permissions enabled by default. Default \"admin\" Possible Values Any alpha numerical value Mandatory password The password of the system adminsitrator. Default \"admin\" Possible Values Any alpha numerical value Mandatory create_admin_account Set this whether the system administrator credentials should be created in the system at the time of starting the server. Default : Enabled Possible Values : Use \"false\" to disable. Mandatory Configuring the keystore Config Heading [keystore.tls] Add this config heading to the ei.toml file to group the parameters that connects the server to the keystore used for SSL handshaking when the server communicates with another server. Default Enabled with default parameters. Mandatory Parameters file_name The name of the keystore file. Default \"wso2carbon.jks\" Possible Values Any file name with the .jks extension. Mandatory type The type of the keystore file. Default \"JKS\" Possible Values \"JKS\" or \"PKCS12\" Mandatory password The password of the keystore file. Default \"wso2carbon\" Possible Values Any alpha numerical value. Mandatory alias The alias of the public key certificate that is included in the keystore. Default \"wso2carbon\" Possible Values Any alpha numerical value. Mandatory key_password The password of the private key that is included in the keystore. Default \"wso2carbon\" Possible Value Any alpha numerical value. Mandatory Configuring the truststore Config Heading [truststore] Add this config heading to the ei.toml file to group the parameters that connects the server to the trustore. Default Enabled with default parameters. Mandatory Parameters file_name The name of the keystore file. Default \"wso2truststore.jks\" Possible Values Any file name with the .jks extension. Mandatory type The type of the keystore file. Default \"JKS\" Possible Values \"JKS\" or \"PKCS12\" Mandatory password The password of the keystore file. Default \"wso2carbon\" Possible Values Any alpha numerical value. Mandatory alias The alias of the public key certificate that is included in the trustore. Default \"symmetric.key.value\" Possible Values Any alpha numerical value. Mandatory key_password The password of the private key that is included in the keystore. Default \"wso2carbon\" Possible Value Any alpha numerical value. Mandatory algorithm The password of the ... Default \"AES\" Possible Value Mandatory","title":"Configuration Catalog"},{"location":"references/config-catalog/#configuration-catalog","text":"This document describes all the configuration parameters that are used in WSO2 Identity Server.","title":"Configuration Catalog"},{"location":"references/config-catalog/#instructions-for-use","text":"Select the configuration sections, parameters, and values that are required for your use and add them to the .toml file. See the example .toml file given below. # This is an example .toml file. [server] pattern= value enable_port_forward=true [key_mgr_node] endpoints= value [gateway] gateway_environments=[ dev , test ] [[database]] pool_options.maxActiv=5","title":"Instructions for use"},{"location":"references/config-catalog/#tuning-the-primary-data-store-connection","text":"Config Heading [database.shared_db.pool_options] The config heading in the ei.toml file that groups the parameters for tuning the performance of the primary database that you configured with the [database.shared_db] section. Default Enabled with default parameters. Mandatory Parameters maxActive The maximum number of active connections that can be allocated at the same time from the pool. If there are too many active connections in the connection pool, some of them would be idle, incurring an unnecessary system overhead. Default \"50\" Possible Values Depends on environment. Enter any negative value to denote an unlimited number of active connections. Optional maxWait The maximum number of milliseconds that the pool will wait (when there are no available connections) for a connection to be returned before throwing an exception. Default \"6000\" Possible Values Depends on environment. Enter zero or a negative value to wait indefinitely. Optional testOnBorrow The indication of whether objects will be validated before being borrowed from the pool. If the object fails to validate, it will be dropped from the pool, and another attempt will be made to borrow another. Default Enabled Possible Value Use \"false\" to disable testOnBorrow. Optional validationInterval The indication to avoid excess validation, and only run validation at the most, at this frequency (time in milliseconds). If a connection is due for validation but has been validated previously within this interval, it will not be validated again. Default \"30000\" Possible Values Depends on environment. Optional defaultAutoCommit Specifies whether each SQL statement should be automatically committed when it is completed. It is recommended to disable auto committing by setting this property to true. Default Enabled Possible Values Use \"false\" to disable default auto commit. Optional","title":"Tuning the primary data store connection"},{"location":"references/config-catalog/#connecting-to-the-user-stores","text":"Config Heading [user_store] The config heading in the ei.toml that connects the server to the user store. The user store holds the users and roles defined for the system. Default Enabled Mandatory Parameters type The type of user store. Default Value : \"database\" Possible Values : \"database\" , \"LDAP\" Mandatory","title":"Connecting to the user stores"},{"location":"references/config-catalog/#configuring-the-system-administrator","text":"Config Heading [super_admin] : The config heading in the ei.toml file that groups the parameters defining the system adminsitrator. Default Enabled with the default parameters. Mandatory Parameters username The user name of the system administrator. This user has all permissions enabled by default. Default \"admin\" Possible Values Any alpha numerical value Mandatory password The password of the system adminsitrator. Default \"admin\" Possible Values Any alpha numerical value Mandatory create_admin_account Set this whether the system administrator credentials should be created in the system at the time of starting the server. Default : Enabled Possible Values : Use \"false\" to disable. Mandatory","title":"Configuring the system administrator"},{"location":"references/config-catalog/#configuring-the-keystore","text":"Config Heading [keystore.tls] Add this config heading to the ei.toml file to group the parameters that connects the server to the keystore used for SSL handshaking when the server communicates with another server. Default Enabled with default parameters. Mandatory Parameters file_name The name of the keystore file. Default \"wso2carbon.jks\" Possible Values Any file name with the .jks extension. Mandatory type The type of the keystore file. Default \"JKS\" Possible Values \"JKS\" or \"PKCS12\" Mandatory password The password of the keystore file. Default \"wso2carbon\" Possible Values Any alpha numerical value. Mandatory alias The alias of the public key certificate that is included in the keystore. Default \"wso2carbon\" Possible Values Any alpha numerical value. Mandatory key_password The password of the private key that is included in the keystore. Default \"wso2carbon\" Possible Value Any alpha numerical value. Mandatory","title":"Configuring the keystore"},{"location":"references/config-catalog/#configuring-the-truststore","text":"Config Heading [truststore] Add this config heading to the ei.toml file to group the parameters that connects the server to the trustore. Default Enabled with default parameters. Mandatory Parameters file_name The name of the keystore file. Default \"wso2truststore.jks\" Possible Values Any file name with the .jks extension. Mandatory type The type of the keystore file. Default \"JKS\" Possible Values \"JKS\" or \"PKCS12\" Mandatory password The password of the keystore file. Default \"wso2carbon\" Possible Values Any alpha numerical value. Mandatory alias The alias of the public key certificate that is included in the trustore. Default \"symmetric.key.value\" Possible Values Any alpha numerical value. Mandatory key_password The password of the private key that is included in the keystore. Default \"wso2carbon\" Possible Value Any alpha numerical value. Mandatory algorithm The password of the ... Default \"AES\" Possible Value Mandatory","title":"Configuring the truststore"},{"location":"references/default-ports-of-wso2-products/","text":"Default Ports of WSO2 Products This page describes the default ports that are used for each WSO2 product when the port offset is 0. If you are running multiple WSO2 products on the same server, you must set the offset value in PRODUCT_HOME /repository/conf/carbon.xml to a different value for each product so that there are no port conflicts. For example, if you are running two WSO2 products on the same server, and you set the port offset to 1 in one product and 2 in the second product, the management console port will be changed from the default of 9443 to 9444 in the first product and to 9445 in the second product. See here for more information on changing the offset. Common ports Product-specific ports Common ports The following ports are common to all WSO2 products that provide the given feature. Some features are bundled in the WSO2 Carbon platform itself and therefore are available in all WSO2 products by default. Management console ports | LDAP server ports | KDC ports | JMX monitoring ports | Clustering ports | Random ports Management console ports WSO2 products that provide a management console use the following servlet transport ports: 9443 - HTTPS servlet transport (the default URL of the management console is https://localhost:9443/carbon ) 9763 - HTTP servlet transport LDAP server ports Provided by default in the WSO2 Carbon platform. 10389 - Used in WSO2 products that provide an embedded LDAP server KDC ports 8000 - Used to expose the Kerberos key distribution center server JMX monitoring ports WSO2 Carbon platform uses TCP ports to monitor a running Carbon instance using a JMX client such as JConsole. By default, JMX is enabled in all products. You can disable it using PRODUCT_HOME /repository/conf/etc/jmx.xml file. 11111 - RMIRegistry port. Used to monitor Carbon remotely 9999 - RMIServer port. Used along with the RMIRegistry port when Carbon is monitored from a JMX client that is behind a firewall Clustering ports To cluster any running Carbon instance, either one of the following ports must be opened. 45564 - Opened if the membership scheme is multicast 4000 - Opened if the membership scheme is wka Random ports Certain ports are randomly opened during server startup. This is due to specific properties and configurations that become effective when the product is started. Note that the IDs of these random ports will change every time the server is started. A random TCP port will open at server startup because of the -Dcom.sun.management.jmxremote property set in the server startup script. This property is used for the JMX monitoring facility in JVM. A random UDP port is opened at server startup due to the log4j appender ( SyslogAppender ), which is configured in the PRODUCT_HOME /repository/conf/log4j.properties file. Product-specific ports Some products open additional ports. API Manager | BAM | BPS | Data Analytics Server | Complex Event Processor | Elastic Load Balancer | ESB | Identity Server | Message Broker | Machine Learner | Storage Server | Enterprise Mobility Manager API Manager 10397 - Thrift client and server ports 8280, 8243 - NIO/PT transport ports 7711 - Thrift SSL port for secure transport, where the client is authenticated to BAM/CEP: stat pub Note If you change the default API Manager ports with a port offset, most of its ports will be changed automatically according to the offset except a few exceptions described in the APIM Manager documentation . BAM 9160 - Cassandra port using which Thrift listens to clients 7711 - Thrift SSL port for secure transport, where the client is authenticated to BAM 7611 - Thrift TCP port to receive events from clients to BAM 21000 - Hive Thrift server starts on this port BPS 2199 - RMI registry port (datasources provider port) Data Analytics Server 9160 - Cassandra port on which Thrift listens to clients 7711 - Thrift SSL port for secure transport, where the client is authenticated to DAS 7611 - Thrift TCP port to receive events from clients to DAS For a list of Apache Spark related ports, see WSO2 Data Analytics Server Documentation - Spark Configurations s . Complex Event Processor 9160 - Cassandra port on which Thrift listens to clients 7711 - Thrift SSL port for secure transport, where the client is authenticated to CEP 7611 - Thrift TCP port to receive events from clients to CEP 11224 - Thrift TCP port for HA management of CEP Elastic Load Balancer 8280, 8243 - NIO/PT transport ports ESB Non-blocking HTTP/S transport ports: Used to accept message mediation requests. If you want to send a request to an API or a proxy service for example, you must use these ports. ESB_HOME}/repository/conf/axis2/axis2.xml file. 8243 - Passthrough or NIO HTTPS transport 8280 - Passthrough or NIO HTTP transport Identity Server 8000 - KDCServerPort. Port which KDC (Kerberos Key Distribution Center) server runs 10500 - ThriftEntitlementReceivePort Message Broker Message Broker uses the following JMS ports to communicate with external clients over the JMS transport. 5672 - Port for listening for messages on TCP when the AMQP transport is used. 8672 - Port for listening for messages on TCP/SSL when the AMQP Transport is used. 1883 - Port for listening for messages on TCP when the MQTT transport is used. 8833 - Port for listening for messages on TCP/SSL when the MQTT Transport is used. 7611 - The port for Apache Thrift Server. Machine Learner 7077 - The default port for Apache Spark. 54321 - The default port for H2O. 4040 - The default port for Spark UI. Storage Server Cassandra: 7000 - For Inter node communication within cluster nodes 7001 - For inter node communication within cluster nodes vis SSL 9160 - For Thrift client connections 7199 - For JMX HDFS: 54310 - Port used to connect to the default file system. 54311 - Port used by the MapRed job tracker 50470 - Name node secure HTTP server port 50475 - Data node secure HTTP server port 50010 - Data node server port for data transferring 50075 - Data node HTTP server port 50020 - Data node IPC server port Enterprise Mobility Manager The following ports need to be opened for Android and iOS devices so that it can connect to Google Cloud Messaging (GCM)/Firebase Cloud Messaging (FCM) and APNS (Apple Push Notification Service) and enroll to WSO2 EMM. Android: The ports to open are 5228, 5229 and 5230. GCM/FCM typically only uses 5228, but it sometimes uses 5229 and 5230. GCM/FCM does not provide specific IPs, so it is recommended to allow the firewall to accept outgoing connections to all IP addresses contained in the IP blocks listed in Google's ASN of 15169. iOS: 5223 - TCP port used by devices to communicate to APNs servers 2195 - TCP port used to send notifications to APNs 2196 - TCP port used by the APNs feedback service 443 - TCP port used as a fallback on Wi-Fi, only when devices are unable to communicate to APNs on port 5223 The APNs servers use load balancing. The devices will not always connect to the same public IP address for notifications. The entire 17.0.0.0/8 address block is assigned to Apple, so it is best to allow this range in the firewall settings. API Manager: The following WSO2 API Manager ports are only applicable to WSO2 EMM 1.1.0 onwards. 10397 - Thrift client and server ports 8280, 8243 - NIO/PT transport ports Changing the offset for default ports When you run multiple WSO2 products, multiple instances of the same product, or multiple WSO2 product clusters on the same server or virtual machines (VMs), you must change their default ports with an offset value to avoid port conflicts. The default HTTP and HTTPS ports (without offset) of a WSO2 product are 9763 and 9443 respectively. Port offset defines the number by which all ports defined in the runtime such as the HTTP/S ports will be changed. For example, if the default HTTP port is 9763 and the port offset is 1, the effective HTTP port will change to 9764. For each additional WSO2 product instance, you set the port offset to a unique value. The default port offset is 0. There are two ways to set an offset to a port: Pass the port offset to the server during startup. The following command starts the server with the default port incremented by 3 :./wso2server.sh -DportOffset=3 Set the Ports section of PRODUCT_HOME /repository/conf/carbon.xml as follows: Offset 3 /Offset Usually, when you offset the port of the server, all ports it uses are changed automatically. However, there are few exceptions as follows in which you have to change the ports manually according to the offset. The following table indicates the changes that occur when the offset value is modified. WSO2 Server instance PortOffset Sample Default Port Value WSO2 Product 1 0 9443 WSO2 Product 2 1 9444 WSO2 Product 3 2 9445 WSO2 Product 4 3 9446 WSO2 Product 5 4 9447","title":"Default Ports of WSO2 Products"},{"location":"references/default-ports-of-wso2-products/#default-ports-of-wso2-products","text":"This page describes the default ports that are used for each WSO2 product when the port offset is 0. If you are running multiple WSO2 products on the same server, you must set the offset value in PRODUCT_HOME /repository/conf/carbon.xml to a different value for each product so that there are no port conflicts. For example, if you are running two WSO2 products on the same server, and you set the port offset to 1 in one product and 2 in the second product, the management console port will be changed from the default of 9443 to 9444 in the first product and to 9445 in the second product. See here for more information on changing the offset. Common ports Product-specific ports","title":"Default Ports of WSO2 Products"},{"location":"references/default-ports-of-wso2-products/#common-ports","text":"The following ports are common to all WSO2 products that provide the given feature. Some features are bundled in the WSO2 Carbon platform itself and therefore are available in all WSO2 products by default. Management console ports | LDAP server ports | KDC ports | JMX monitoring ports | Clustering ports | Random ports","title":"Common ports"},{"location":"references/default-ports-of-wso2-products/#management-console-ports","text":"WSO2 products that provide a management console use the following servlet transport ports: 9443 - HTTPS servlet transport (the default URL of the management console is https://localhost:9443/carbon ) 9763 - HTTP servlet transport","title":"Management console ports"},{"location":"references/default-ports-of-wso2-products/#ldap-server-ports","text":"Provided by default in the WSO2 Carbon platform. 10389 - Used in WSO2 products that provide an embedded LDAP server","title":"LDAP server ports"},{"location":"references/default-ports-of-wso2-products/#kdc-ports","text":"8000 - Used to expose the Kerberos key distribution center server","title":"KDC ports"},{"location":"references/default-ports-of-wso2-products/#jmx-monitoring-ports","text":"WSO2 Carbon platform uses TCP ports to monitor a running Carbon instance using a JMX client such as JConsole. By default, JMX is enabled in all products. You can disable it using PRODUCT_HOME /repository/conf/etc/jmx.xml file. 11111 - RMIRegistry port. Used to monitor Carbon remotely 9999 - RMIServer port. Used along with the RMIRegistry port when Carbon is monitored from a JMX client that is behind a firewall","title":"JMX monitoring ports"},{"location":"references/default-ports-of-wso2-products/#clustering-ports","text":"To cluster any running Carbon instance, either one of the following ports must be opened. 45564 - Opened if the membership scheme is multicast 4000 - Opened if the membership scheme is wka","title":"Clustering ports"},{"location":"references/default-ports-of-wso2-products/#random-ports","text":"Certain ports are randomly opened during server startup. This is due to specific properties and configurations that become effective when the product is started. Note that the IDs of these random ports will change every time the server is started. A random TCP port will open at server startup because of the -Dcom.sun.management.jmxremote property set in the server startup script. This property is used for the JMX monitoring facility in JVM. A random UDP port is opened at server startup due to the log4j appender ( SyslogAppender ), which is configured in the PRODUCT_HOME /repository/conf/log4j.properties file.","title":"Random ports"},{"location":"references/default-ports-of-wso2-products/#product-specific-ports","text":"Some products open additional ports. API Manager | BAM | BPS | Data Analytics Server | Complex Event Processor | Elastic Load Balancer | ESB | Identity Server | Message Broker | Machine Learner | Storage Server | Enterprise Mobility Manager","title":"Product-specific ports"},{"location":"references/default-ports-of-wso2-products/#api-manager","text":"10397 - Thrift client and server ports 8280, 8243 - NIO/PT transport ports 7711 - Thrift SSL port for secure transport, where the client is authenticated to BAM/CEP: stat pub Note If you change the default API Manager ports with a port offset, most of its ports will be changed automatically according to the offset except a few exceptions described in the APIM Manager documentation .","title":"API Manager"},{"location":"references/default-ports-of-wso2-products/#bam","text":"9160 - Cassandra port using which Thrift listens to clients 7711 - Thrift SSL port for secure transport, where the client is authenticated to BAM 7611 - Thrift TCP port to receive events from clients to BAM 21000 - Hive Thrift server starts on this port","title":"BAM"},{"location":"references/default-ports-of-wso2-products/#bps","text":"2199 - RMI registry port (datasources provider port)","title":"BPS"},{"location":"references/default-ports-of-wso2-products/#data-analytics-server","text":"9160 - Cassandra port on which Thrift listens to clients 7711 - Thrift SSL port for secure transport, where the client is authenticated to DAS 7611 - Thrift TCP port to receive events from clients to DAS For a list of Apache Spark related ports, see WSO2 Data Analytics Server Documentation - Spark Configurations s .","title":"Data Analytics Server"},{"location":"references/default-ports-of-wso2-products/#complex-event-processor","text":"9160 - Cassandra port on which Thrift listens to clients 7711 - Thrift SSL port for secure transport, where the client is authenticated to CEP 7611 - Thrift TCP port to receive events from clients to CEP 11224 - Thrift TCP port for HA management of CEP","title":"Complex Event Processor"},{"location":"references/default-ports-of-wso2-products/#elastic-load-balancer","text":"8280, 8243 - NIO/PT transport ports","title":"Elastic Load Balancer"},{"location":"references/default-ports-of-wso2-products/#esb","text":"Non-blocking HTTP/S transport ports: Used to accept message mediation requests. If you want to send a request to an API or a proxy service for example, you must use these ports. ESB_HOME}/repository/conf/axis2/axis2.xml file. 8243 - Passthrough or NIO HTTPS transport 8280 - Passthrough or NIO HTTP transport","title":"ESB"},{"location":"references/default-ports-of-wso2-products/#identity-server","text":"8000 - KDCServerPort. Port which KDC (Kerberos Key Distribution Center) server runs 10500 - ThriftEntitlementReceivePort","title":"Identity Server"},{"location":"references/default-ports-of-wso2-products/#message-broker","text":"Message Broker uses the following JMS ports to communicate with external clients over the JMS transport. 5672 - Port for listening for messages on TCP when the AMQP transport is used. 8672 - Port for listening for messages on TCP/SSL when the AMQP Transport is used. 1883 - Port for listening for messages on TCP when the MQTT transport is used. 8833 - Port for listening for messages on TCP/SSL when the MQTT Transport is used. 7611 - The port for Apache Thrift Server.","title":"Message Broker"},{"location":"references/default-ports-of-wso2-products/#machine-learner","text":"7077 - The default port for Apache Spark. 54321 - The default port for H2O. 4040 - The default port for Spark UI.","title":"Machine Learner"},{"location":"references/default-ports-of-wso2-products/#storage-server","text":"Cassandra: 7000 - For Inter node communication within cluster nodes 7001 - For inter node communication within cluster nodes vis SSL 9160 - For Thrift client connections 7199 - For JMX HDFS: 54310 - Port used to connect to the default file system. 54311 - Port used by the MapRed job tracker 50470 - Name node secure HTTP server port 50475 - Data node secure HTTP server port 50010 - Data node server port for data transferring 50075 - Data node HTTP server port 50020 - Data node IPC server port","title":"Storage Server"},{"location":"references/default-ports-of-wso2-products/#enterprise-mobility-manager","text":"The following ports need to be opened for Android and iOS devices so that it can connect to Google Cloud Messaging (GCM)/Firebase Cloud Messaging (FCM) and APNS (Apple Push Notification Service) and enroll to WSO2 EMM. Android: The ports to open are 5228, 5229 and 5230. GCM/FCM typically only uses 5228, but it sometimes uses 5229 and 5230. GCM/FCM does not provide specific IPs, so it is recommended to allow the firewall to accept outgoing connections to all IP addresses contained in the IP blocks listed in Google's ASN of 15169. iOS: 5223 - TCP port used by devices to communicate to APNs servers 2195 - TCP port used to send notifications to APNs 2196 - TCP port used by the APNs feedback service 443 - TCP port used as a fallback on Wi-Fi, only when devices are unable to communicate to APNs on port 5223 The APNs servers use load balancing. The devices will not always connect to the same public IP address for notifications. The entire 17.0.0.0/8 address block is assigned to Apple, so it is best to allow this range in the firewall settings. API Manager: The following WSO2 API Manager ports are only applicable to WSO2 EMM 1.1.0 onwards. 10397 - Thrift client and server ports 8280, 8243 - NIO/PT transport ports","title":"Enterprise Mobility Manager"},{"location":"references/default-ports-of-wso2-products/#changing-the-offset-for-default-ports","text":"When you run multiple WSO2 products, multiple instances of the same product, or multiple WSO2 product clusters on the same server or virtual machines (VMs), you must change their default ports with an offset value to avoid port conflicts. The default HTTP and HTTPS ports (without offset) of a WSO2 product are 9763 and 9443 respectively. Port offset defines the number by which all ports defined in the runtime such as the HTTP/S ports will be changed. For example, if the default HTTP port is 9763 and the port offset is 1, the effective HTTP port will change to 9764. For each additional WSO2 product instance, you set the port offset to a unique value. The default port offset is 0. There are two ways to set an offset to a port: Pass the port offset to the server during startup. The following command starts the server with the default port incremented by 3 :./wso2server.sh -DportOffset=3 Set the Ports section of PRODUCT_HOME /repository/conf/carbon.xml as follows: Offset 3 /Offset Usually, when you offset the port of the server, all ports it uses are changed automatically. However, there are few exceptions as follows in which you have to change the ports manually according to the offset. The following table indicates the changes that occur when the offset value is modified. WSO2 Server instance PortOffset Sample Default Port Value WSO2 Product 1 0 9443 WSO2 Product 2 1 9444 WSO2 Product 3 2 9445 WSO2 Product 4 3 9446 WSO2 Product 5 4 9447","title":"Changing the offset for default ports"},{"location":"tutorials/adaptive-authentication-overview/","text":"Adaptive Authentication Overview Adaptive authentication is a secure and flexible form of authentication. It enables validating multiple factors to determine the authenticity of a login attempt before granting access to a resource. The factors that are used for validation can depend on the risk probability associated with the particular user access request. This enables adjusting the authentication strength based on the context at hand. WSO2 Identity Server (WSO2 IS) supports script-based adaptive authentication, which allows you to use a script to set up appropriate authentication factors depending on your scenario. This enables ensuring security without impacting usability at the time of authentication. The following section provides a detailed description of how WSO2 IS supports adaptive authentication. Tip To learn more about adaptive authentication, see the following articles: Four reasons to upgrade your MFA to adaptive authentication Five instances to use adaptive authentication Four reasons to use WSO2 Identity Server for adaptive authentication Adaptive Authentication with WSO2 Identity Server The WSO2 IS management console provides an authentication script editor that allows you to define authentication scripts using JavaScript . The script editor provides a set of predefined templates that you can use to easily set up adaptive authentication for some of the most common authentication scenarios. You can define scripts that can consider the following evaluation criteria: User attributes User behaviour Level of assurance of the access request Risk analysis statistics Machine learning algorithms You can define dynamic authentication sequences that can perform actions similar to the following: Control the authentication step selection Change user attributes Send email notifications Redirect users to an error page etc. If necessary you can use the script editor to introduce new functions and fields to an authentication script based on your requirement, and then engage the script to the service provider\u2019s authentication step configuration. Following is a sample authentication script. function onLoginRequest(context) { // Some possible initializations... executeStep(1, { onSuccess: function (context) { // Logic to execute if step 1 succeeded executeStep(2, { onSuccess: function (context){ // Logic to execute if step 2 succeeded }, onFail: function (context){ // Logic to execute if step 2 failed } }); } onFail: function(context){ // Logic to execute if step 1 failed executeStep(3); } }); } function someCommonFunction(context) { // Do some common things } What's Next? To try out adaptive authentication, see Configuring a Service Provider for Adaptive Authentication . To set up common adaptive authentication scenarios, see Adaptive Authentication Scenarios . To learn about the functions and fields related to authentication scripts, see Adaptive Authentication JS API Reference . To learn about the guidelines on writing custom functions for adaptive authentication, see Writing Custom Functions for Adaptive Authentication .","title":"Adaptive Authentication Overview"},{"location":"tutorials/adaptive-authentication-overview/#adaptive-authentication-overview","text":"Adaptive authentication is a secure and flexible form of authentication. It enables validating multiple factors to determine the authenticity of a login attempt before granting access to a resource. The factors that are used for validation can depend on the risk probability associated with the particular user access request. This enables adjusting the authentication strength based on the context at hand. WSO2 Identity Server (WSO2 IS) supports script-based adaptive authentication, which allows you to use a script to set up appropriate authentication factors depending on your scenario. This enables ensuring security without impacting usability at the time of authentication. The following section provides a detailed description of how WSO2 IS supports adaptive authentication. Tip To learn more about adaptive authentication, see the following articles: Four reasons to upgrade your MFA to adaptive authentication Five instances to use adaptive authentication Four reasons to use WSO2 Identity Server for adaptive authentication","title":"Adaptive Authentication Overview"},{"location":"tutorials/adaptive-authentication-overview/#adaptive-authentication-with-wso2-identity-server","text":"The WSO2 IS management console provides an authentication script editor that allows you to define authentication scripts using JavaScript . The script editor provides a set of predefined templates that you can use to easily set up adaptive authentication for some of the most common authentication scenarios. You can define scripts that can consider the following evaluation criteria: User attributes User behaviour Level of assurance of the access request Risk analysis statistics Machine learning algorithms You can define dynamic authentication sequences that can perform actions similar to the following: Control the authentication step selection Change user attributes Send email notifications Redirect users to an error page etc. If necessary you can use the script editor to introduce new functions and fields to an authentication script based on your requirement, and then engage the script to the service provider\u2019s authentication step configuration. Following is a sample authentication script. function onLoginRequest(context) { // Some possible initializations... executeStep(1, { onSuccess: function (context) { // Logic to execute if step 1 succeeded executeStep(2, { onSuccess: function (context){ // Logic to execute if step 2 succeeded }, onFail: function (context){ // Logic to execute if step 2 failed } }); } onFail: function(context){ // Logic to execute if step 1 failed executeStep(3); } }); } function someCommonFunction(context) { // Do some common things }","title":"Adaptive Authentication with WSO2 Identity Server"},{"location":"tutorials/adaptive-authentication-overview/#whats-next","text":"To try out adaptive authentication, see Configuring a Service Provider for Adaptive Authentication . To set up common adaptive authentication scenarios, see Adaptive Authentication Scenarios . To learn about the functions and fields related to authentication scripts, see Adaptive Authentication JS API Reference . To learn about the guidelines on writing custom functions for adaptive authentication, see Writing Custom Functions for Adaptive Authentication .","title":"What's Next?"},{"location":"tutorials/adaptive-authentication-scenarios/","text":"Adaptive Authentication Scenarios Tip To learn more about adaptive authentication, see the following resources. Introduction to Adaptive Authentication [Article] Five instances to use adaptive authentication This section guides you through using pre-defined templates for common adaptive authentication usecases. Configuring Role-Based Adaptive Authentication Configuring User-Age-Based Adaptive Authentication Configuring Tenant-Based Adaptive Authentication Configuring User Store-Based Adaptive Authentication Configuring IP-Based Adaptive Authentication Configuring New-Device-Based Adaptive Authentication Configuring ACR-Based Adaptive Authentication Configuring Risk-Based Adaptive Authentication Using WSO2 Stream Processor for Adaptive Authentication","title":"Adaptive Authentication Scenarios"},{"location":"tutorials/adaptive-authentication-scenarios/#adaptive-authentication-scenarios","text":"Tip To learn more about adaptive authentication, see the following resources. Introduction to Adaptive Authentication [Article] Five instances to use adaptive authentication This section guides you through using pre-defined templates for common adaptive authentication usecases. Configuring Role-Based Adaptive Authentication Configuring User-Age-Based Adaptive Authentication Configuring Tenant-Based Adaptive Authentication Configuring User Store-Based Adaptive Authentication Configuring IP-Based Adaptive Authentication Configuring New-Device-Based Adaptive Authentication Configuring ACR-Based Adaptive Authentication Configuring Risk-Based Adaptive Authentication Using WSO2 Stream Processor for Adaptive Authentication","title":"Adaptive Authentication Scenarios"},{"location":"tutorials/configuring-a-service-provider-for-adaptive-authentication/","text":"Configuring a Service Provider for Adaptive Authentication Adaptive authentication uses machine learning to enable an identity provider to prompt multi-factor authentication steps based on a user's risk profile or user behavior, i.e., the authentication adapts to the situation or the user during the authentication process. For instance, high-risk logins such as a user attempting to log in from an unusual location causes the adaptive authentication mechanism to prompt an extra authentication in order to increase security. For more information on adaptive authentication with WSO2 IS, see Adaptive Authentication . This tutorial guides you through setting up a sample application to try out adaptive authentication and configuring it as a service provider in WSO2 IS. Tip Before you begin , Download and install Apache Tomcat version 8.*.* or higher. Install WSO2 IS version 5.7.0. by downloading the installer . Open the /etc/hosts file, add the following entry, and restart your computer. 127.0.0.1 localhost.com Note: To avoid any IP address conflicts, ensure that this is the only entry for this IP address in the /etc/hosts file. Step 01: Set Up the Samples Follow the steps below to set up the sample application to try out adaptive authentication using a sample application. PickUp sample web application (SAML). Download the saml2-web-app-pickup-dispatch.com.war file and paste it inside the TOMCAT_HOME /webapps directory. Start the tomcat server and access the PickUp application URL at http://localhost.com:8080/saml2-web-app-pickup-dispatch.com. Note that a login screen appears. Deploy the sample authenticator dependency and web application in WSO2 IS. Download the org.wso2.carbon.identity.sample.extension.authenticators-5.7.0.jar file and paste inside the IS_HOME /repository/components/dropins directory. Download the sample-auth.war file and paste it inside the IS_HOME /repository/deployment/server/webapps folder. This .war file contains the WEB UI for the sample authenticators used in this tutorial. Start the WSO2 IS server and test whether all the samples are configured successfully. Sign in to the WSO2 IS Management Console with one of the following URLs using admin as the username and password . java For HTTP -- http:// HTTP_HOST :9776/carbon For HTTPS -- https:// HTTPS_HOST :9443/carbon On the Main tab, click Service Providers Add . Enter test as the Service Provider Name and click Register. ** ** Expand the Local and Outbound Configuration section. The following authenticators should be available in the local authenticators list. Demo Fingerprint Authenticator Demo Hardware-Key Authenticator Demo Face ID Authenticator Remain in the Management Console. Note These Demo Authenticators are provided as a way of learning and experimenting the adaptive authentication templates in realtime. These authenticators perform no real function and should not be used for any production or QA purposes. Step 02: Configure the Service Provider In this step, let's configure a service provider for the sample application by setting up inbound authentication. This tutorial guides you through setting up a service provider for a SAML application. To configure a service provider with other protocols such as OAuth and WS-Federation, see Configuring Inbound Authentication for a Service Provider . On the Main tab, click Service Providers Add and add a new service provider called saml2-web-app-dispatch.com . For more information about configuring a service provider, see Adding and Configuring a Service Provider . Expand the Inbound Authentication configuration SAML2 Web SSO configuration section, and click Configure . Fill in the following fields. Issuer: saml2-web-app-pickup-dispatch.com Assertion Consumer URL: http://localhost.com:8080/saml2-web-app-pickup-dispatch.com/consumer Leave the rest of the default configurations as it is and click Register . Expand Local and Outbound Authentication Configuration and click Advanced Configuration . You can add authentication steps or use a template to configure adaptive authentication depending on your requirement. For example, add Demo HardwareKey Authenticator. What's Next? Now that you have set up the service provider, the sample application, and the demo authenticators, you can try out the following scenarios that use pre-defined templates for different adaptive authentication use cases.","title":"Configuring a Service Provider for Adaptive Authentication"},{"location":"tutorials/configuring-a-service-provider-for-adaptive-authentication/#configuring-a-service-provider-for-adaptive-authentication","text":"Adaptive authentication uses machine learning to enable an identity provider to prompt multi-factor authentication steps based on a user's risk profile or user behavior, i.e., the authentication adapts to the situation or the user during the authentication process. For instance, high-risk logins such as a user attempting to log in from an unusual location causes the adaptive authentication mechanism to prompt an extra authentication in order to increase security. For more information on adaptive authentication with WSO2 IS, see Adaptive Authentication . This tutorial guides you through setting up a sample application to try out adaptive authentication and configuring it as a service provider in WSO2 IS. Tip Before you begin , Download and install Apache Tomcat version 8.*.* or higher. Install WSO2 IS version 5.7.0. by downloading the installer . Open the /etc/hosts file, add the following entry, and restart your computer. 127.0.0.1 localhost.com Note: To avoid any IP address conflicts, ensure that this is the only entry for this IP address in the /etc/hosts file.","title":"Configuring a Service Provider for Adaptive Authentication"},{"location":"tutorials/configuring-a-service-provider-for-adaptive-authentication/#step-01-set-up-the-samples","text":"Follow the steps below to set up the sample application to try out adaptive authentication using a sample application. PickUp sample web application (SAML). Download the saml2-web-app-pickup-dispatch.com.war file and paste it inside the TOMCAT_HOME /webapps directory. Start the tomcat server and access the PickUp application URL at http://localhost.com:8080/saml2-web-app-pickup-dispatch.com. Note that a login screen appears. Deploy the sample authenticator dependency and web application in WSO2 IS. Download the org.wso2.carbon.identity.sample.extension.authenticators-5.7.0.jar file and paste inside the IS_HOME /repository/components/dropins directory. Download the sample-auth.war file and paste it inside the IS_HOME /repository/deployment/server/webapps folder. This .war file contains the WEB UI for the sample authenticators used in this tutorial. Start the WSO2 IS server and test whether all the samples are configured successfully. Sign in to the WSO2 IS Management Console with one of the following URLs using admin as the username and password . java For HTTP -- http:// HTTP_HOST :9776/carbon For HTTPS -- https:// HTTPS_HOST :9443/carbon On the Main tab, click Service Providers Add . Enter test as the Service Provider Name and click Register. ** ** Expand the Local and Outbound Configuration section. The following authenticators should be available in the local authenticators list. Demo Fingerprint Authenticator Demo Hardware-Key Authenticator Demo Face ID Authenticator Remain in the Management Console. Note These Demo Authenticators are provided as a way of learning and experimenting the adaptive authentication templates in realtime. These authenticators perform no real function and should not be used for any production or QA purposes.","title":"Step 01: Set Up the Samples"},{"location":"tutorials/configuring-a-service-provider-for-adaptive-authentication/#step-02-configure-the-service-provider","text":"In this step, let's configure a service provider for the sample application by setting up inbound authentication. This tutorial guides you through setting up a service provider for a SAML application. To configure a service provider with other protocols such as OAuth and WS-Federation, see Configuring Inbound Authentication for a Service Provider . On the Main tab, click Service Providers Add and add a new service provider called saml2-web-app-dispatch.com . For more information about configuring a service provider, see Adding and Configuring a Service Provider . Expand the Inbound Authentication configuration SAML2 Web SSO configuration section, and click Configure . Fill in the following fields. Issuer: saml2-web-app-pickup-dispatch.com Assertion Consumer URL: http://localhost.com:8080/saml2-web-app-pickup-dispatch.com/consumer Leave the rest of the default configurations as it is and click Register . Expand Local and Outbound Authentication Configuration and click Advanced Configuration . You can add authentication steps or use a template to configure adaptive authentication depending on your requirement. For example, add Demo HardwareKey Authenticator.","title":"Step 02: Configure the Service Provider"},{"location":"tutorials/configuring-a-service-provider-for-adaptive-authentication/#whats-next","text":"Now that you have set up the service provider, the sample application, and the demo authenticators, you can try out the following scenarios that use pre-defined templates for different adaptive authentication use cases.","title":"What's Next?"},{"location":"tutorials/configuring-role-based-adaptive-authentication/","text":"Configuring Role-Based Adaptive Authentication This tutorial demonstrates how you can set up role-based adaptive authentication with WSO2 Identity Server (WSO2 IS). To understand how to set up role-based adaptive authentication with WSO2 IS, let's consider a scenario where you want a user who has an administrator role to perform an additional level of authentication while any other user can just provide their credentials (basic authentication) to access a resource. Here, you will use a sample application named to deploy and set up sample authenticators required to try out the scenario. Tip Before you begin Set up the service provider and sample application for adaptive authentication if you have not done so already. For instructions on how to do this, see Configuring a Service Provider for Adaptive Authentication . For more information about adaptive authentication with WSO2 Identity Server, see Adaptive Authentication . Configuring the sample scenario Log in to the management console and create a new user named 'Alex'. Do not assign any roles. Navigate to Service Providers List and click Edit on the saml2-web-app-dispatch.com service provider. Expand the Local and Outbound Configuration section and click Advanced Authentication . Expand Script Based Conditional Authentication . Click Templates on the right side of the Script Based Conditional Authentication field and then click Role-Based . Click Ok . The authentication script and authentication steps are configured. The authentication script defines a conditional step that executes the second authentication step (i.e., hardware key authenticator) only if the user belongs to an 'admin' or 'manager' role. The authentication steps added are totp and fido . However, these are authentication steps that you would normally use in production. To try out sample authenticators with the sample application, delete the two authenticators and add the following sample authenticators instead. Click Delete to remove the totp and fido authenticators from Step 2 (the second authentication step). Select Demo Hardware Key Authenticator and click Add . Click Update . Testing the sample scenario Access the following sample PickUp application URL: http://localhost.com:8080/saml2-web-app-dispatch.com Click Login and enter admin/admin credentials. You are prompted to use the hardware key after basic authentication according to the authentication step defined in the JavaScript above. Enter the 4 digit key given on the screen and click Sign In . Next, log out of the application and log in again as 'Alex'. Note that this user is not assigned to any role. You will see that authentication is successful only after going through the basic authentication step. What's Next? The following scenarios demonstrate the use of adaptive authentication templates and scripts to try out other use cases.","title":"Configuring Role-Based Adaptive Authentication"},{"location":"tutorials/configuring-role-based-adaptive-authentication/#configuring-role-based-adaptive-authentication","text":"This tutorial demonstrates how you can set up role-based adaptive authentication with WSO2 Identity Server (WSO2 IS). To understand how to set up role-based adaptive authentication with WSO2 IS, let's consider a scenario where you want a user who has an administrator role to perform an additional level of authentication while any other user can just provide their credentials (basic authentication) to access a resource. Here, you will use a sample application named to deploy and set up sample authenticators required to try out the scenario. Tip Before you begin Set up the service provider and sample application for adaptive authentication if you have not done so already. For instructions on how to do this, see Configuring a Service Provider for Adaptive Authentication . For more information about adaptive authentication with WSO2 Identity Server, see Adaptive Authentication .","title":"Configuring Role-Based Adaptive Authentication"},{"location":"tutorials/configuring-role-based-adaptive-authentication/#configuring-the-sample-scenario","text":"Log in to the management console and create a new user named 'Alex'. Do not assign any roles. Navigate to Service Providers List and click Edit on the saml2-web-app-dispatch.com service provider. Expand the Local and Outbound Configuration section and click Advanced Authentication . Expand Script Based Conditional Authentication . Click Templates on the right side of the Script Based Conditional Authentication field and then click Role-Based . Click Ok . The authentication script and authentication steps are configured. The authentication script defines a conditional step that executes the second authentication step (i.e., hardware key authenticator) only if the user belongs to an 'admin' or 'manager' role. The authentication steps added are totp and fido . However, these are authentication steps that you would normally use in production. To try out sample authenticators with the sample application, delete the two authenticators and add the following sample authenticators instead. Click Delete to remove the totp and fido authenticators from Step 2 (the second authentication step). Select Demo Hardware Key Authenticator and click Add . Click Update .","title":"Configuring the sample scenario"},{"location":"tutorials/configuring-role-based-adaptive-authentication/#testing-the-sample-scenario","text":"Access the following sample PickUp application URL: http://localhost.com:8080/saml2-web-app-dispatch.com Click Login and enter admin/admin credentials. You are prompted to use the hardware key after basic authentication according to the authentication step defined in the JavaScript above. Enter the 4 digit key given on the screen and click Sign In . Next, log out of the application and log in again as 'Alex'. Note that this user is not assigned to any role. You will see that authentication is successful only after going through the basic authentication step.","title":"Testing the sample scenario"},{"location":"tutorials/configuring-role-based-adaptive-authentication/#whats-next","text":"The following scenarios demonstrate the use of adaptive authentication templates and scripts to try out other use cases.","title":"What's Next?"},{"location":"tutorials/configuring-tenant-based-adaptive-authentication/","text":"Configuring Tenant-Based Adaptive Authentication This tutorial demonstrates tenant-based adaptive authentication with WSO2 Identity Server using sample authenticators. This is useful if you want to add security for users logging in from external tenant domains. Using the tenant-based adaptive authentication template, you can whitelist certain tenant domains so that users from the whitelisted domains are prompted to perform an additional level of authentication, while users from any other tenant domain can simply provide their credentials (basic authentication) to access a resource. Tip Before you begin Set up the service provider and sample application for adaptive authentication. For instructions on how to do this, see Configuring a Service Provider for Adaptive Authentication . For more information about adaptive authentication with WSO2 Identity Server, see Adaptive Authentication . Configuring the sample scenario Log in to the management console. Click Add New Tenant under Multitenancy on the Configure tab. Enter tenant details as shown below to register a new tenant for the domain \" abc.com \". Select Demo as the Usage Plan for Tenant and enter user details for the tenant admin. Similarly, register a new tenant for the domain \"123.com\" with a different tenant admin. Navigate to the Main tab of the management console and click List under Service Providers . Edit the saml2-web-app-dispatch.com service provider and select Saas application . This enables users from other tenant domains such as abc.com or 123.com to log in to the application. Expand the Local and Outbound Configuration section and click Advanced Authentication . Click on Templates on the right side of the Script Based Conditional Authentication field and then click Tenant-Based . Click Ok . The authentication script and authentication steps are configured. The authentication script prompts the second step of authentication for users that belong to the tenant domains named \" abc.com \" and \" xyz.com \". The second authentication step that is added is totp. However, totp is an authentication step that you would normally use in production. To try out this scenario sample authenticators with the sample application, delete the totp authenticator and add the following sample authenticator instead. Click Delete to remove the totp authenticator from Step 2 (the second authentication step). Select Demo Hardware Key Authenticator and click Add . Click Update . Trying out the sample scenario Log out of the management console and log in with the abc.com tenant admin's credentials (alex@abc.com). Create a new user in the abc.com tenant named \"chris\" and ensure that he has login permissions. Access the following sample PickUp application URL: http://localhost.com:8080/saml2-web-app-dispatch.com Click Login and enter Chris's credentials. Enter the username with the appended tenant domain (i.e., chris@abc.com). Note that you are prompted for harware key authentication because abc.com is a whitelisted tenant domain. Enter the 4 digit key and click Sign In . You are successfully logged in to the application. Log out and log in with Kim's credentials. Kim is the admin of the 123.com tenant domain, which is not one of the whitelisted domains. Provide consent. Note that you are successfully logged in to the application after going through the basic authentication step only. What's Next? The following scenarios demonstrate the use of adaptive authentication templates and scripts to try out other use cases.","title":"Configuring Tenant-Based Adaptive Authentication"},{"location":"tutorials/configuring-tenant-based-adaptive-authentication/#configuring-tenant-based-adaptive-authentication","text":"This tutorial demonstrates tenant-based adaptive authentication with WSO2 Identity Server using sample authenticators. This is useful if you want to add security for users logging in from external tenant domains. Using the tenant-based adaptive authentication template, you can whitelist certain tenant domains so that users from the whitelisted domains are prompted to perform an additional level of authentication, while users from any other tenant domain can simply provide their credentials (basic authentication) to access a resource. Tip Before you begin Set up the service provider and sample application for adaptive authentication. For instructions on how to do this, see Configuring a Service Provider for Adaptive Authentication . For more information about adaptive authentication with WSO2 Identity Server, see Adaptive Authentication .","title":"Configuring Tenant-Based Adaptive Authentication"},{"location":"tutorials/configuring-tenant-based-adaptive-authentication/#configuring-the-sample-scenario","text":"Log in to the management console. Click Add New Tenant under Multitenancy on the Configure tab. Enter tenant details as shown below to register a new tenant for the domain \" abc.com \". Select Demo as the Usage Plan for Tenant and enter user details for the tenant admin. Similarly, register a new tenant for the domain \"123.com\" with a different tenant admin. Navigate to the Main tab of the management console and click List under Service Providers . Edit the saml2-web-app-dispatch.com service provider and select Saas application . This enables users from other tenant domains such as abc.com or 123.com to log in to the application. Expand the Local and Outbound Configuration section and click Advanced Authentication . Click on Templates on the right side of the Script Based Conditional Authentication field and then click Tenant-Based . Click Ok . The authentication script and authentication steps are configured. The authentication script prompts the second step of authentication for users that belong to the tenant domains named \" abc.com \" and \" xyz.com \". The second authentication step that is added is totp. However, totp is an authentication step that you would normally use in production. To try out this scenario sample authenticators with the sample application, delete the totp authenticator and add the following sample authenticator instead. Click Delete to remove the totp authenticator from Step 2 (the second authentication step). Select Demo Hardware Key Authenticator and click Add . Click Update .","title":"Configuring the sample scenario"},{"location":"tutorials/configuring-tenant-based-adaptive-authentication/#trying-out-the-sample-scenario","text":"Log out of the management console and log in with the abc.com tenant admin's credentials (alex@abc.com). Create a new user in the abc.com tenant named \"chris\" and ensure that he has login permissions. Access the following sample PickUp application URL: http://localhost.com:8080/saml2-web-app-dispatch.com Click Login and enter Chris's credentials. Enter the username with the appended tenant domain (i.e., chris@abc.com). Note that you are prompted for harware key authentication because abc.com is a whitelisted tenant domain. Enter the 4 digit key and click Sign In . You are successfully logged in to the application. Log out and log in with Kim's credentials. Kim is the admin of the 123.com tenant domain, which is not one of the whitelisted domains. Provide consent. Note that you are successfully logged in to the application after going through the basic authentication step only.","title":"Trying out the sample scenario"},{"location":"tutorials/configuring-tenant-based-adaptive-authentication/#whats-next","text":"The following scenarios demonstrate the use of adaptive authentication templates and scripts to try out other use cases.","title":"What's Next?"},{"location":"tutorials/configuring-user-age-based-adaptive-authentication/","text":"Configuring User-Age-Based Adaptive Authentication This scenario demonstrates user-age-based adaptive authentication in WSO2 Identity Server using sample authenticators. The instructions below guide you through specifying authentication steps based on the user's age. In this example, any user who is underage and below the specified age limit (i.e., under the age of 18 years) is restricted access and prevented from logging in to the application. Tip Before you begin Set up the service provider and sample application for adaptive authentication. For instructions on how to do this, see Configuring a Service Provider for Adaptive Authentication . For more information about adaptive authentication with WSO2 Identity Server, see Adaptive Authentication . Configuring the sample scenario Log in to the management console. Click List under Claims and click http://wso2.org/claims . Click on the Edit corresponding to the BirthDate claim and select the Supported By Default checkbox to enable the birth date claim. Create a user called \"Alex\" and edit the user profile. Enter a birth date that specifies Alex as under 18 years of age. Enter the birth date in the following format: yyyy-mm-dd . Next, create another user called \"Kim\" and edit the user profile. Enter a birth date that specifies Kim as over 18 years of age. Enter the birth date in the following format: yyyy-mm-dd . Navigate to Service Providers List and click Edit on the saml2-web-app-dispatch.com service provider. Expand the Local and Outbound Authentication Configuration section and click Advanced Configuration . C lick on Templates on the right side of the Script Based Conditional Authentication field and then click User-Age-Based . Click Ok . The authentication script and authentication steps are configured. The authentication script grants access only to users who are 18 years or above and restricts underage users. Underage users are redirected to an error page. Click Update . Trying out the sample scenario Access the following sample PickUp application URL: http://localhost.com:8080/saml2-web-app-dispatch.com Click Login and enter Kim's credentials. You are successfully logged in to the application. Logout and login as Alex. Note that you are now restricted from logging in because Alex is underage. What's Next? The following scenarios demonstrate the use of adaptive authentication templates and scripts to try out other use cases.","title":"Configuring User-Age-Based Adaptive Authentication"},{"location":"tutorials/configuring-user-age-based-adaptive-authentication/#configuring-user-age-based-adaptive-authentication","text":"This scenario demonstrates user-age-based adaptive authentication in WSO2 Identity Server using sample authenticators. The instructions below guide you through specifying authentication steps based on the user's age. In this example, any user who is underage and below the specified age limit (i.e., under the age of 18 years) is restricted access and prevented from logging in to the application. Tip Before you begin Set up the service provider and sample application for adaptive authentication. For instructions on how to do this, see Configuring a Service Provider for Adaptive Authentication . For more information about adaptive authentication with WSO2 Identity Server, see Adaptive Authentication .","title":"Configuring User-Age-Based Adaptive Authentication"},{"location":"tutorials/configuring-user-age-based-adaptive-authentication/#configuring-the-sample-scenario","text":"Log in to the management console. Click List under Claims and click http://wso2.org/claims . Click on the Edit corresponding to the BirthDate claim and select the Supported By Default checkbox to enable the birth date claim. Create a user called \"Alex\" and edit the user profile. Enter a birth date that specifies Alex as under 18 years of age. Enter the birth date in the following format: yyyy-mm-dd . Next, create another user called \"Kim\" and edit the user profile. Enter a birth date that specifies Kim as over 18 years of age. Enter the birth date in the following format: yyyy-mm-dd . Navigate to Service Providers List and click Edit on the saml2-web-app-dispatch.com service provider. Expand the Local and Outbound Authentication Configuration section and click Advanced Configuration . C lick on Templates on the right side of the Script Based Conditional Authentication field and then click User-Age-Based . Click Ok . The authentication script and authentication steps are configured. The authentication script grants access only to users who are 18 years or above and restricts underage users. Underage users are redirected to an error page. Click Update .","title":"Configuring the sample scenario"},{"location":"tutorials/configuring-user-age-based-adaptive-authentication/#trying-out-the-sample-scenario","text":"Access the following sample PickUp application URL: http://localhost.com:8080/saml2-web-app-dispatch.com Click Login and enter Kim's credentials. You are successfully logged in to the application. Logout and login as Alex. Note that you are now restricted from logging in because Alex is underage.","title":"Trying out the sample scenario"},{"location":"tutorials/configuring-user-age-based-adaptive-authentication/#whats-next","text":"The following scenarios demonstrate the use of adaptive authentication templates and scripts to try out other use cases.","title":"What's Next?"}]}